# Feature: Rework Join Game Flow - Implementation Plan

> **Generated by:** Task Decomposition skill
> **From spec:** specs/26db45-rework-join-game-flow/spec.md
> **Created:** 2025-11-04
> **Run ID:** 26db45
> **Feature:** rework-join-game-flow

## Execution Summary

- **Total Tasks**: 7
- **Total Phases**: 5
- **Sequential Time**: 27h
- **Parallel Time**: 19h
- **Time Savings**: 8h (30%)

**Parallel Opportunities:**

- Phase 5: 3 tasks (8h saved)

---

## Phase 1: Database Foundation

**Strategy**: sequential
**Reason**: Foundation layer - all other tasks depend on schema changes

### Task 1: Database Schema Migration

**Files**:
- `prisma/schema.prisma`
- `prisma/migrations/` (generated)

**Complexity**: M (4h)

**Dependencies**: None (foundation layer)

**Description**:

Remove the `@unique` constraint from `Game.accessCode` to allow multiple games to use the same access code (scoping codes to games rather than globally unique). Add `@@index([accessCode])` for query performance when looking up games by access code.

This enables the core requirement: multiple independent games can use simple, memorable codes like "OSCAR" without collision risk.

**Implementation Steps**:

1. Update `prisma/schema.prisma`:
   - Remove `@unique` from `Game.accessCode` field
   - Add `@@index([accessCode])` to Game model (after existing indexes)
2. Run `pnpm db:migrate` to generate migration
3. Name migration: "remove-accesscode-unique-add-index"
4. Verify migration runs successfully on dev database
5. Check existing games retain their access codes
6. Run `pnpm db:studio` to inspect schema changes

**Acceptance Criteria**:

- [ ] `Game.accessCode` has no `@unique` constraint in schema.prisma
- [ ] `Game` model has `@@index([accessCode])`
- [ ] Migration runs successfully with `pnpm db:migrate`
- [ ] Existing games in dev database retain their access codes
- [ ] Can insert multiple games with same accessCode value

**Mandatory Patterns**:

> **Constitution**: All code must follow `@docs/constitutions/current/`

See `schema-rules.md` for:
- Index on frequently queried fields (accessCode)
- Preserve existing @@unique constraints (GameParticipant)
- Follow naming conventions (camelCase fields, PascalCase models)

**Quality Gates**:

```bash
# Verify migration
pnpm db:migrate

# Inspect schema
pnpm db:studio
```

---

## Phase 2: API Contracts & Schemas

**Strategy**: sequential
**Reason**: Depends on schema changes from Phase 1

### Task 2: Update API Contracts and Zod Schemas

**Files**:
- `src/schemas/game-schema.ts`
- `src/lib/api/contracts/game.ts`

**Complexity**: M (3h)

**Dependencies**: Task 1 (schema changes provide context for validation rules)

**Description**:

Update Zod schemas and oRPC contracts to require both `gameId` and `accessCode` for join operations, replacing the single-parameter `resolveAccessCode` API. This enforces compound key validation at the contract level.

Remove the `resolveAccessCode` contract entirely since all join operations will validate both parameters together.

**Implementation Steps**:

1. Update `src/schemas/game-schema.ts`:
   - Modify `joinGameSchema` to include both fields:
     - `gameId: z.string().cuid("Invalid game ID")`
     - `accessCode: z.string().regex(/^[A-Z0-9]+$/, "Access code must be uppercase alphanumeric")`
   - Remove `resolveAccessCodeSchema` (no longer needed)
2. Update `src/lib/api/contracts/game.ts`:
   - Update `joinContract` input to use new `joinGameSchema`
   - Keep existing output structure (GameParticipant fields)
   - Remove `resolveAccessCodeContract` entirely
   - Update `gameContract` router export to remove `resolveAccessCode`
3. Verify TypeScript types compile

**Acceptance Criteria**:

- [ ] `joinGameSchema` requires both `gameId` (cuid) and `accessCode` (regex)
- [ ] `joinContract` uses updated `joinGameSchema` as input
- [ ] `resolveAccessCodeSchema` removed from game-schema.ts
- [ ] `resolveAccessCodeContract` removed from game.ts
- [ ] TypeScript compilation succeeds with no type errors

**Mandatory Patterns**:

> **Constitution**: All code must follow `@docs/constitutions/current/`

See `patterns.md` for:
- oRPC contract-first with `oc.input().output()`
- Zod schemas for all inputs
- Contract validation before implementation

**Quality Gates**:

```bash
# Type checking
pnpm lint

# Verify contracts compile
pnpm build
```

---

## Phase 3: Service Layer

**Strategy**: sequential
**Reason**: Depends on schemas from Phase 2 for validation

### Task 3: Update Game Service Join Method

**Files**:
- `src/lib/services/game-service.ts`

**Complexity**: M (4h)

**Dependencies**: Task 1 (queries schema), Task 2 (uses joinGameSchema)

**Description**:

Update the `gameService.join()` method to accept and validate both `gameId` and `accessCode` as a compound key. This is the core business logic change: instead of looking up games by access code alone, we now validate the specific combination of game ID and access code together.

Use `ts-pattern` for game status validation (OPEN or LIVE only). Maintain idempotent behavior (return existing participant if already a member).

**Implementation Steps**:

1. **Write tests first** (TDD):
   - Test compound key validation (gameId + accessCode match)
   - Test invalid game ID (not found)
   - Test invalid access code for valid game ID (mismatch)
   - Test game status validation (SETUP → reject, OPEN → allow, LIVE → allow, COMPLETED → reject)
   - Test idempotent behavior (already a member → return existing)
   - Test successful join (create new GameParticipant)
2. Update `gameService.join()` method signature:
   - Change from `join(userId: string, accessCode: string)`
   - To: `join(userId: string, gameId: string, accessCode: string)`
3. Implement compound key query:
   - `await gameModel.findFirst({ id: gameId, accessCode })`
   - Throw error if not found: "Game not found or invalid access code"
4. Validate game status using `ts-pattern`:
   - `match(game.status).with('OPEN', () => true).with('LIVE', () => true).with('SETUP', () => false).with('COMPLETED', () => false).exhaustive()`
   - Throw appropriate error for non-joinable status
5. Check existing membership via `gameParticipantModel.exists(userId, gameId)`
6. Create participant if not exists, otherwise return existing
7. Run tests to verify all cases pass

**Acceptance Criteria**:

- [ ] `join()` method accepts `userId`, `gameId`, `accessCode` parameters
- [ ] Queries game with compound WHERE clause: `{ id: gameId, accessCode }`
- [ ] Throws error if game not found or accessCode mismatch
- [ ] Uses `ts-pattern` with `.exhaustive()` for status validation
- [ ] Returns existing participant if user already a member (idempotent)
- [ ] Creates new GameParticipant for valid join operations
- [ ] All tests pass (TDD - tests written first)

**Mandatory Patterns**:

> **Constitution**: All code must follow `@docs/constitutions/current/`

See `architecture.md` for:
- Services call models, never Prisma directly
- Business logic in service layer only
- No oRPC imports in services

See `patterns.md` for:
- `ts-pattern` with `.exhaustive()` for discriminated unions
- Proper error handling with descriptive messages

See `testing.md` for:
- TDD: Write tests first, watch fail, minimal code, watch pass
- Test all error paths and edge cases

**Quality Gates**:

```bash
# Run tests (TDD)
pnpm test src/lib/services/game-service.test.ts

# Type checking
pnpm lint
```

---

## Phase 4: API Router

**Strategy**: sequential
**Reason**: Depends on service layer from Phase 3

### Task 4: Update Game Router Join Procedure

**Files**:
- `src/lib/api/routers/game.ts`

**Complexity**: M (3h)

**Dependencies**: Task 2 (uses contracts), Task 3 (calls service)

**Description**:

Update the `join` procedure implementation to accept both `gameId` and `accessCode` from the updated contract. Remove the `resolveAccessCode` procedure entirely. This completes the API layer changes.

Use `implement(contract)` pattern to ensure type safety from contract to implementation.

**Implementation Steps**:

1. Update `src/lib/api/routers/game.ts`:
   - Locate `join` procedure implementation
   - Update handler to destructure both `input.gameId` and `input.accessCode`
   - Call `gameService.join(ctx.userId, input.gameId, input.accessCode)` with both params
   - Keep existing response structure (return participant)
2. Remove `resolveAccessCode` procedure:
   - Delete the entire procedure implementation
   - Remove from router export
3. Verify router uses `implement(gameContract)` pattern
4. Test API endpoint manually or with integration tests

**Acceptance Criteria**:

- [ ] `join` procedure accepts `{ gameId, accessCode }` from input
- [ ] Calls `gameService.join()` with `userId`, `gameId`, `accessCode`
- [ ] `resolveAccessCode` procedure removed from router
- [ ] Router uses `implement(gameContract)` pattern
- [ ] TypeScript compilation succeeds
- [ ] Manual test: join API works with both parameters

**Mandatory Patterns**:

> **Constitution**: All code must follow `@docs/constitutions/current/`

See `architecture.md` for:
- oRPC procedures call services, never models directly
- Use `implement(contract)` for type safety

See `patterns.md` for:
- oRPC contract-first pattern
- Proper error propagation from service layer

**Quality Gates**:

```bash
# Type checking
pnpm lint

# Build verification
pnpm build

# Manual API test (optional)
# curl http://localhost:3000/api/orpc/game.join -d '{"gameId":"...", "accessCode":"..."}'
```

---

## Phase 5: UI Layer (Parallel)

**Strategy**: parallel
**Reason**: All three tasks depend on Phase 4 (API router), but have no shared files - can be implemented concurrently

### Task 5: Create Join Route

**Files**:
- `src/lib/routes.ts`
- `src/app/join/[gameId]/page.tsx` (new)

**Complexity**: M (5h)

**Dependencies**: Task 4 (calls join API via serverClient)

**Description**:

Create the canonical join route `/join/[gameId]?code={accessCode}` that handles all join operations. This is a Server Component that validates authentication, extracts parameters, calls the join API, and redirects on success.

This route becomes the single entry point for joining games, whether from signup flow, dashboard, or direct links.

**Implementation Steps**:

1. Update `src/lib/routes.ts`:
   - Add join route function: `join: (gameId: string, code: string) => \`/join/\${gameId}?code=\${code}\``
2. Create `src/app/join/[gameId]/page.tsx`:
   - Define props with `params: Promise<{ gameId: string }>` and `searchParams: Promise<{ code?: string }>`
   - Await params and searchParams per Next.js 15 conventions
   - Call `requireValidatedSession()` for authentication
   - Validate `code` query param exists (redirect to dashboard if missing)
   - Try/catch block:
     - Call `serverClient.game.join({ gameId, accessCode: code })`
     - Success: `redirect(routes.game.pick(gameId))`
     - Error: Display error UI with message and link to dashboard
3. Create error UI component (inline or extract):
   - Display user-friendly error message
   - Include "Return to Dashboard" link
   - Style with existing UI components
4. Test route manually:
   - Valid gameId + code → redirects to picks
   - Invalid code → shows error
   - Missing code → redirects to dashboard
   - Not authenticated → redirects to sign-in

**Acceptance Criteria**:

- [ ] `routes.join(gameId, code)` returns `/join/{gameId}?code={code}`
- [ ] Route requires authentication via `requireValidatedSession()`
- [ ] Awaits `params` and `searchParams` per Next.js 15
- [ ] Calls `serverClient.game.join({ gameId, accessCode })`
- [ ] Redirects to `routes.game.pick(gameId)` on success
- [ ] Displays error message on failure with dashboard link
- [ ] Redirects to dashboard if `code` param missing

**Mandatory Patterns**:

> **Constitution**: All code must follow `@docs/constitutions/current/`

See `patterns.md` for:
- Async params and searchParams (Next.js 15)
- `requireValidatedSession()` for protected routes
- Centralized routes from `src/lib/routes.ts`
- Server Component with serverClient for API calls
- Standalone server action for redirect

**Quality Gates**:

```bash
# Type checking
pnpm lint

# Manual testing
pnpm dev
# Navigate to /join/{gameId}?code={code}
```

---

### Task 6: Add Dashboard Join UI

**Files**:
- `src/app/dashboard/page.tsx`
- `src/components/join-game-form.tsx` (new)

**Complexity**: M (4h)

**Dependencies**: Task 4 (calls join API via orpc)

**Description**:

Add a "Join Game" feature to the dashboard page, allowing authenticated users to join additional games. This is a Client Component form that accepts Game ID and Access Code inputs, calls the join API, and navigates to the pick wizard on success.

This completes the user-facing feature for authenticated users to join games without needing signup links.

**Implementation Steps**:

1. Create `src/components/join-game-form.tsx` (Client Component):
   - Add `"use client"` directive
   - Form with two inputs:
     - Game ID (text input, placeholder "Enter Game ID")
     - Access Code (text input, uppercase, placeholder "Enter Access Code")
   - Use `useMutation(orpc.game.join.mutationOptions())`
   - Display loading state during mutation
   - Success: Call `router.push(routes.game.pick(gameId))` or trigger refetch
   - Error: Display inline error message
   - Style with existing UI components (shadcn/ui)
2. Update `src/app/dashboard/page.tsx`:
   - Import JoinGameForm component
   - Add "Join Game" button/section to page
   - Option A: Modal/dialog with form
   - Option B: Collapsible section with form
   - Maintain existing dashboard content (games list)
3. Test UI manually:
   - Valid inputs → navigates to picks
   - Invalid game ID → shows error
   - Invalid code → shows error
   - Empty inputs → validation error

**Acceptance Criteria**:

- [ ] Dashboard page shows "Join Game" button/section
- [ ] Form accepts Game ID and Access Code inputs
- [ ] Client-side validation before submission
- [ ] Uses `useMutation(orpc.game.join.mutationOptions())`
- [ ] Shows loading state during API call
- [ ] Navigates to `routes.game.pick(gameId)` on success
- [ ] Displays inline error message on failure

**Mandatory Patterns**:

> **Constitution**: All code must follow `@docs/constitutions/current/`

See `patterns.md` for:
- Client Components with `"use client"` directive
- `useMutation(orpc.*.mutationOptions())` for mutations
- Centralized routes from `src/lib/routes.ts`
- React Query for state management

See `architecture.md` for:
- UI layer calls oRPC (Client Components use orpc)
- Event handlers only in Client Components

**Quality Gates**:

```bash
# Type checking
pnpm lint

# Manual testing
pnpm dev
# Navigate to /dashboard and test form
```

---

### Task 7: Update Signup Flow

**Files**:
- `src/app/signup/page.tsx`
- `src/app/signup/callback/page.tsx`
- `src/app/signup/callback/join-game-handler.tsx` (delete)

**Complexity**: M (4h)

**Dependencies**: Task 5 (redirects to join route)

**Description**:

Simplify the signup flow to redirect to the canonical join route instead of handling join logic directly. Update messaging on the signup page when a code is present. Update the callback page to perform a one-time lookup to find which game matches the access code, then redirect to the join route.

Delete the `JoinGameHandler` client component since join logic now lives in the dedicated join route.

**Implementation Steps**:

1. Update `src/app/signup/page.tsx`:
   - Check for `?code` query param
   - If present, display message: "You'll join the game after signing in"
   - No API calls in this component (pure UI)
   - Keep existing signup form/logic
2. Update `src/app/signup/callback/page.tsx`:
   - Check for `?code` query param
   - If present:
     - Query games to find which gameId matches this accessCode
     - Use `gameModel.findFirst({ where: { accessCode: code } })` or similar
     - Redirect to `routes.join(gameId, code)`
   - If not present: redirect to `routes.dashboard()`
3. Delete `src/app/signup/callback/join-game-handler.tsx`:
   - Remove file entirely
   - Remove import from callback page
4. Test signup flow:
   - New user signs up with `?code=TEST` → redirects to join route → joins game
   - New user signs up without code → redirects to dashboard
   - Existing user signs in with code → redirects to join route

**Acceptance Criteria**:

- [ ] `/signup?code={code}` displays "You'll join after signing in" message
- [ ] `/signup/callback?code={code}` looks up gameId for access code
- [ ] Callback redirects to `routes.join(gameId, code)` when code present
- [ ] Callback redirects to dashboard when no code
- [ ] `JoinGameHandler` component deleted
- [ ] No imports of deleted component remain
- [ ] Signup flow completes successfully for new and existing users

**Mandatory Patterns**:

> **Constitution**: All code must follow `@docs/constitutions/current/`

See `patterns.md` for:
- Async params and searchParams (Next.js 15)
- Centralized routes from `src/lib/routes.ts`
- Server Components for data fetching
- Standalone server action for redirects

**Quality Gates**:

```bash
# Type checking
pnpm lint

# Remove deleted file references
# Verify no imports of join-game-handler.tsx

# Manual testing
pnpm dev
# Test signup flow with and without code param
```

---

## Testing Strategy

### Test Coverage Requirements

**Unit Tests** (TDD):
- `src/lib/services/game-service.test.ts`:
  - Compound key validation (gameId + accessCode)
  - Invalid game ID
  - Invalid access code
  - Game status validation (all statuses)
  - Idempotent join (already a member)
  - Successful join (create participant)

**Integration Tests** (optional):
- Join API endpoint with valid/invalid inputs
- Signup callback → join route flow
- Dashboard form → join API → pick redirect

**Manual Testing**:
- Complete join flow from signup link
- Join from dashboard UI
- Direct join link access
- Error states and messaging

### Quality Gates

All tasks must pass:

```bash
# Type checking and formatting
pnpm lint

# Unit tests
pnpm test

# Build verification
pnpm build
```

---

## Migration & Rollout

**Database Migration**:

1. Run `pnpm db:migrate` after Task 1 completes
2. Verify existing games retain access codes
3. Safe to deploy incrementally (backward compatible until cleanup)

**Feature Flags**: None required (pure addition, removes deprecated code at end)

**Rollback Plan**:

- Tasks 1-4: Revert migrations and code changes
- Tasks 5-7: Remove new routes, restore old signup flow

---

## Constitution References

> **All tasks MUST follow**: `@docs/constitutions/current/`

**Key Documents**:

- `architecture.md`: Layer boundaries, dependency rules
- `patterns.md`: Next.js 15 async params, oRPC, auth patterns
- `schema-rules.md`: Database design and indexing
- `testing.md`: TDD requirements and test organization

**Mandatory Patterns**:

1. ✅ Await `params` and `searchParams` (Next.js 15)
2. ✅ Use `requireValidatedSession()` for protected routes
3. ✅ Use oRPC contract-first with `implement(contract)`
4. ✅ Use centralized routes from `src/lib/routes.ts`
5. ✅ Client Components use `useMutation(orpc.*.mutationOptions())`
6. ✅ Use `ts-pattern` with `.exhaustive()` for discriminated unions
7. ✅ Services call models, never Prisma directly
8. ✅ oRPC procedures call services, never models directly
9. ✅ TDD: Write tests first, watch fail, implement, watch pass

---

## Next Steps

**Review this plan:**

```bash
cat specs/26db45-rework-join-game-flow/plan.md
```

**Execute plan:**

```bash
/spectacular:execute @specs/26db45-rework-join-game-flow/plan.md
```

**Track progress:**

- Watch subagents execute tasks in parallel (Phase 5)
- Review PRs per phase
- Verify quality gates pass
- Test end-to-end flow after completion
