# Database & Authentication Setup - Implementation Plan

> **Generated by:** Task Decomposition skill
> **From spec:** specs/database-auth-setup/spec.md
> **Created:** 2025-10-17

## Execution Summary

- **Total Tasks**: 6 phases
- **Total Phases**: 6 (all sequential)
- **Estimated Time**: 8-10 hours
- **Parallel Opportunities**: None (each phase depends on previous)

**Dependencies**: Each phase must complete before the next begins due to infrastructure dependencies.

---

## Phase 1: Database Infrastructure

**Strategy**: Sequential
**Reason**: Foundation layer - all subsequent work depends on this

### Task 1.1: Setup Docker & Environment Files

**Files**:
- `docker-compose.yml` (new)
- `.env.example` (new)
- `.env.local` (new)

**Complexity**: S (1h)

**Dependencies**: None

**Description**:
Create Docker Compose configuration for PostgreSQL 15 database and environment variable templates for local and example configurations.

**Implementation Steps**:
1. Create `docker-compose.yml` with PostgreSQL 15 service
   - Image: `postgres:15`
   - Port: `5432:5432`
   - Environment: POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB
   - Volume: `postgres_data` for persistence
2. Create `.env.example` with all required variables (empty values)
3. Create `.env.local` with local development values
   - DATABASE_URL: `postgresql://postgres:postgres@localhost:5432/bignight`
   - AUTH_SECRET: Generate with `openssl rand -base64 32`
   - NEXTAUTH_URL: `http://localhost:3000`
   - RESEND_API_KEY: (placeholder for now)
   - EMAIL_FROM: `dev@bignight.party`
   - ADMIN_EMAILS: Your email for testing
4. Add `.env.local` to `.gitignore` if not already present
5. Start Docker: `docker compose up -d`
6. Verify: `docker ps` shows PostgreSQL container running

**Acceptance Criteria**:
- [ ] `docker-compose.yml` creates PostgreSQL 15 container
- [ ] Container starts successfully: `docker compose up -d`
- [ ] PostgreSQL accessible on localhost:5432
- [ ] `.env.example` includes all required variables
- [ ] `.env.local` has valid DATABASE_URL
- [ ] `.env.local` is gitignored

**Mandatory Patterns** (BigNight.Party):
- Environment variables: Never commit `.env.local`
- Database credentials: Different in production
- **TDD**: N/A for infrastructure setup

**Quality Gates**:
```bash
docker ps | grep postgres       # Container running
docker compose logs postgres    # No errors
```

---

## Phase 2: Prisma Setup

**Strategy**: Sequential
**Reason**: Depends on Phase 1 (database must be running)

### Task 2.1: Install Prisma Dependencies

**Files**:
- `package.json` (modify)

**Complexity**: S (0.5h)

**Dependencies**: Phase 1 complete

**Description**:
Install Prisma CLI and client packages, add database scripts to package.json.

**Implementation Steps**:
1. Install Prisma packages:
   ```bash
   pnpm add @prisma/client
   pnpm add -D prisma
   ```
2. Add scripts to `package.json`:
   ```json
   {
     "scripts": {
       "db:generate": "prisma generate",
       "db:push": "prisma db push",
       "db:migrate": "prisma migrate dev",
       "db:studio": "prisma studio"
     }
   }
   ```
3. Verify installation: `pnpm prisma --version`

**Acceptance Criteria**:
- [ ] `@prisma/client` installed as dependency
- [ ] `prisma` installed as devDependency
- [ ] Package scripts added for Prisma commands
- [ ] `pnpm prisma --version` works

**Mandatory Patterns** (BigNight.Party):
- Use pnpm (not npm/yarn)
- Pin versions in package.json
- **TDD**: N/A for dependency installation

**Quality Gates**:
```bash
pnpm prisma --version    # Shows version number
pnpm lint                # Biome passes
```

### Task 2.2: Create Prisma Schema

**Files**:
- `prisma/schema.prisma` (new)

**Complexity**: M (2h)

**Dependencies**: Task 2.1 complete

**Description**:
Define Prisma schema with Auth.js required models (User, Account, VerificationToken) and Role enum.

**Implementation Steps**:
1. Initialize Prisma: `pnpm prisma init` (creates `prisma/schema.prisma`)
2. Configure datasource and generator:
   ```prisma
   datasource db {
     provider = "postgresql"
     url      = env("DATABASE_URL")
   }

   generator client {
     provider = "prisma-client-js"
   }
   ```
3. Create Role enum:
   ```prisma
   enum Role {
     USER
     ADMIN
   }
   ```
4. Create User model (see spec Appendix for complete schema)
   - Fields: id, email, role, emailVerified, name, image, createdAt, updatedAt
   - Relations: accounts[]
   - Indexes: email (unique)
5. Create Account model (Auth.js adapter schema)
   - Fields: id, userId, type, provider, providerAccountId, refresh_token, access_token, expires_at, token_type, scope, id_token, session_state
   - Relations: user
   - Composite unique: [provider, providerAccountId]
   - Index: userId
6. Create VerificationToken model
   - Fields: identifier, token, expires
   - Unique: token
   - Composite unique: [identifier, token]
7. Verify schema: `pnpm prisma format`

**Acceptance Criteria**:
- [ ] Schema includes User, Account, VerificationToken models
- [ ] Role enum defined (USER, ADMIN)
- [ ] All indexes defined per schema-rules.md
- [ ] `pnpm prisma format` runs without errors
- [ ] Schema follows Auth.js v5 adapter requirements

**Mandatory Patterns** (BigNight.Party):
- Follow schema-rules.md naming conventions
- camelCase for field names
- PascalCase for model names
- **TDD**: N/A for schema definition

**Quality Gates**:
```bash
pnpm prisma format       # Formats schema
pnpm prisma validate     # Validates schema syntax
```

### Task 2.3: Create Prisma Client Singleton

**Files**:
- `src/lib/db/prisma.ts` (new)

**Complexity**: S (0.5h)

**Dependencies**: Task 2.2 complete

**Description**:
Create Prisma client singleton to prevent multiple instances in development (hot reload issue).

**Implementation Steps**:
1. Create `src/lib/db/` directory
2. Create `src/lib/db/prisma.ts` with singleton pattern (see spec Appendix)
3. Export prisma client instance
4. Configure logging for development: `log: ['query', 'error', 'warn']`
5. Add type safety for global scope

**Acceptance Criteria**:
- [ ] Singleton pattern prevents multiple Prisma clients
- [ ] Logging enabled in development
- [ ] No Prisma imports outside src/lib/db/ (architecture.md)
- [ ] TypeScript types correct

**Mandatory Patterns** (BigNight.Party):
- Layer boundaries: Prisma only in src/lib/db/
- No business logic in this file
- **TDD**: Unit test for singleton pattern (future)

**Quality Gates**:
```bash
pnpm biome check --write src/lib/db/
```

### Task 2.4: Generate Prisma Client & Run Migration

**Files**:
- `prisma/migrations/` (new directory with migration files)
- `node_modules/.prisma/` (generated types)

**Complexity**: S (1h)

**Dependencies**: Task 2.3 complete

**Description**:
Generate Prisma client types and create initial database migration.

**Implementation Steps**:
1. Generate Prisma client: `pnpm prisma generate`
   - Creates TypeScript types in `node_modules/.prisma/`
   - Enables autocomplete for database queries
2. Create initial migration: `pnpm prisma migrate dev --name init`
   - Creates `prisma/migrations/TIMESTAMP_init/` directory
   - Generates SQL migration file
   - Applies migration to database
3. Verify tables created: `pnpm prisma studio`
   - Open Prisma Studio (http://localhost:5555)
   - Confirm User, Account, VerificationToken tables exist
4. Test database connection in code:
   ```typescript
   import { prisma } from '@/lib/db/prisma'
   await prisma.user.count() // Should return 0
   ```

**Acceptance Criteria**:
- [ ] `pnpm prisma generate` creates types
- [ ] Migration runs successfully: `pnpm db:migrate`
- [ ] Prisma Studio shows all tables
- [ ] Database connection works from code
- [ ] TypeScript autocomplete works for prisma queries

**Mandatory Patterns** (BigNight.Party):
- Migration-based schema evolution (no db push in production)
- Never edit applied migrations
- **TDD**: Integration test for database connection (future)

**Quality Gates**:
```bash
pnpm prisma studio                # Opens without errors
pnpm prisma migrate status        # Shows applied migrations
```

---

## Phase 3: Auth.js Configuration

**Strategy**: Sequential
**Reason**: Depends on Phase 2 (Prisma client must exist)

### Task 3.1: Install Auth.js Dependencies

**Files**:
- `package.json` (modify)

**Complexity**: S (0.5h)

**Dependencies**: Phase 2 complete

**Description**:
Install Auth.js v5, Prisma adapter, Zod, and Resend packages.

**Implementation Steps**:
1. Install Auth.js packages:
   ```bash
   pnpm add next-auth@beta @auth/prisma-adapter zod resend
   ```
2. Verify versions:
   - next-auth: 5.0.0-beta.25 (or latest beta)
   - @auth/prisma-adapter: ^2.0.0
   - zod: ^3.22.0
   - resend: ^4.0.0
3. Check package.json for correct versions

**Acceptance Criteria**:
- [ ] Auth.js v5 (beta) installed
- [ ] Prisma adapter installed
- [ ] Zod validation library installed
- [ ] Resend email provider installed

**Mandatory Patterns** (BigNight.Party):
- Use Auth.js v5 for Next.js 15 compatibility (tech-stack.md)
- Zod for all validation (not joi, not yup)
- **TDD**: N/A for dependency installation

**Quality Gates**:
```bash
pnpm list next-auth      # Shows beta version
pnpm lint                # Biome passes
```

### Task 3.2: Create Auth.js Configuration

**Files**:
- `src/lib/auth/config.ts` (new)

**Complexity**: M (2h)

**Dependencies**: Task 3.1 complete

**Description**:
Configure Auth.js with Resend provider, Prisma adapter, JWT strategy, and role-based callbacks.

**Implementation Steps**:
1. Create `src/lib/auth/` directory
2. Create `src/lib/auth/config.ts` (see spec Appendix for complete code)
3. Import Prisma client from `@/lib/db/prisma`
4. Configure NextAuth with:
   - PrismaAdapter(prisma)
   - Resend provider with EMAIL_FROM env var
   - JWT session strategy (not database)
5. Add JWT callback:
   - Assign userId from user.id
   - Assign role based on ADMIN_EMAILS env var
6. Add session callback:
   - Attach userId and role to session.user
7. Export { handlers, auth, signIn, signOut }
8. Add AUTH_SECRET to `.env.local`: `openssl rand -base64 32`

**Acceptance Criteria**:
- [ ] Magic link provider configured with Resend
- [ ] JWT strategy enabled (no Session model)
- [ ] Role assigned from ADMIN_EMAILS env var
- [ ] Session includes userId, email, role
- [ ] AUTH_SECRET generated and added to .env.local

**Mandatory Patterns** (BigNight.Party):
- Auth config in src/lib/auth/ (architecture.md)
- Environment variables for secrets
- **TDD**: Unit test for role assignment logic (future)

**Quality Gates**:
```bash
pnpm biome check --write src/lib/auth/
pnpm build                        # Builds without type errors
```

### Task 3.3: Create Auth.js API Route

**Files**:
- `src/app/api/auth/[...nextauth]/route.ts` (new)

**Complexity**: S (0.5h)

**Dependencies**: Task 3.2 complete

**Description**:
Create Next.js API route to handle Auth.js authentication requests.

**Implementation Steps**:
1. Create directory: `src/app/api/auth/[...nextauth]/`
2. Create `route.ts` file
3. Import handlers from `@/lib/auth/config`
4. Export GET and POST handlers:
   ```typescript
   import { handlers } from '@/lib/auth/config'
   export const { GET, POST } = handlers
   ```
5. Test endpoint: Start dev server and visit `/api/auth/signin`
6. Verify Resend provider shows in sign-in UI

**Acceptance Criteria**:
- [ ] API route created at correct path
- [ ] Exports GET and POST handlers
- [ ] `/api/auth/signin` endpoint accessible
- [ ] Auth.js built-in UI renders

**Mandatory Patterns** (BigNight.Party):
- Use App Router route handlers (not Pages Router)
- **TDD**: E2E test for auth endpoint (future)

**Quality Gates**:
```bash
pnpm dev                          # Start dev server
curl http://localhost:3000/api/auth/signin  # Returns HTML
```

---

## Phase 4: Server Actions & Validation

**Strategy**: Sequential
**Reason**: Depends on Phase 3 (Auth.js config must exist)

### Task 4.1: Install next-safe-action & ts-pattern

**Files**:
- `package.json` (modify)

**Complexity**: S (0.5h)

**Dependencies**: Phase 3 complete

**Description**:
Install next-safe-action for type-safe server actions and ts-pattern for exhaustive matching.

**Implementation Steps**:
1. Install packages:
   ```bash
   pnpm add next-safe-action ts-pattern
   ```
2. Verify versions:
   - next-safe-action: ^8.0.0
   - ts-pattern: ^5.0.0

**Acceptance Criteria**:
- [ ] next-safe-action installed
- [ ] ts-pattern installed
- [ ] Both listed in package.json dependencies

**Mandatory Patterns** (BigNight.Party):
- ALL server actions must use next-safe-action (patterns.md)
- ALL discriminated unions must use ts-pattern (patterns.md)
- **TDD**: N/A for dependency installation

**Quality Gates**:
```bash
pnpm list next-safe-action       # Shows version
pnpm list ts-pattern              # Shows version
```

### Task 4.2: Create Safe Action Clients

**Files**:
- `src/lib/actions/safe-action.ts` (new)

**Complexity**: M (1.5h)

**Dependencies**: Task 4.1 complete

**Description**:
Create next-safe-action client instances with authentication middleware.

**Implementation Steps**:
1. Create `src/lib/actions/` directory
2. Create `safe-action.ts` (see spec Appendix for complete code)
3. Create three action clients:
   - `action`: Base client (no auth required)
   - `authenticatedAction`: Requires valid session
   - `adminAction`: Requires ADMIN role
4. Implement middleware for `authenticatedAction`:
   - Call `await auth()` from Auth.js config
   - Throw error if no session
   - Return context with userId and userRole
5. Implement middleware for `adminAction`:
   - Call `await auth()` from Auth.js config
   - Throw error if no session or role !== 'ADMIN'
   - Return context with userId
6. Export all three clients

**Acceptance Criteria**:
- [ ] Three safe action clients created (action, authenticatedAction, adminAction)
- [ ] authenticatedAction middleware checks session
- [ ] adminAction middleware checks ADMIN role
- [ ] Context includes userId and userRole
- [ ] TypeScript types inferred correctly

**Mandatory Patterns** (BigNight.Party):
- Use next-safe-action for ALL server actions (patterns.md)
- Middleware pattern for auth/authorization
- **TDD**: Unit test for middleware logic (future)

**Quality Gates**:
```bash
pnpm biome check --write src/lib/actions/
pnpm build                        # No TypeScript errors
```

### Task 4.3: Create Auth Validation Schema

**Files**:
- `src/schemas/auth-schema.ts` (new)

**Complexity**: S (0.5h)

**Dependencies**: Task 4.1 complete (Zod installed)

**Description**:
Create Zod schema for email validation in sign-in form.

**Implementation Steps**:
1. Create `src/schemas/` directory
2. Create `auth-schema.ts`
3. Define emailSchema with Zod:
   ```typescript
   import { z } from 'zod'

   export const emailSchema = z.object({
     email: z.string().email('Please enter a valid email address'),
   })

   export type EmailInput = z.infer<typeof emailSchema>
   ```
4. Export schema and inferred type

**Acceptance Criteria**:
- [ ] Email validation with Zod
- [ ] Custom error message for invalid email
- [ ] TypeScript type inferred from schema
- [ ] Schema follows Zod best practices

**Mandatory Patterns** (BigNight.Party):
- All validation with Zod schemas (patterns.md)
- Schemas in src/schemas/ directory (architecture.md)
- **TDD**: Unit test for schema validation (future)

**Quality Gates**:
```bash
pnpm biome check --write src/schemas/
```

### Task 4.4: Create Sign-Out Action

**Files**:
- `src/lib/actions/auth-actions.ts` (new)

**Complexity**: M (1h)

**Dependencies**: Tasks 4.2 and 4.3 complete

**Description**:
Create type-safe server action for signing out users.

**Implementation Steps**:
1. Create `auth-actions.ts` in `src/lib/actions/`
2. Add 'use server' directive
3. Import `authenticatedAction` from `./safe-action`
4. Import `signOut` from Auth.js config
5. Import `redirect` from next/navigation
6. Create signOutAction:
   ```typescript
   export const signOutAction = authenticatedAction.action(async () => {
     await signOut()
     redirect('/sign-in')
   })
   ```
7. Ensure action is type-safe with no manual validation

**Acceptance Criteria**:
- [ ] Sign-out action uses authenticatedAction
- [ ] Action clears session cookie (via signOut)
- [ ] Action redirects to /sign-in
- [ ] Type-safe with proper error handling
- [ ] No manual auth checks (middleware handles it)

**Mandatory Patterns** (BigNight.Party):
- Server actions use next-safe-action (patterns.md)
- Actions only call services, not models directly (architecture.md)
- **TDD**: Integration test for sign-out flow (future)

**Quality Gates**:
```bash
pnpm biome check --write src/lib/actions/
pnpm build                        # No errors
```

---

## Phase 5: UI & Middleware

**Strategy**: Sequential
**Reason**: Depends on Phase 4 (actions and schemas must exist)

### Task 5.1: Create Sign-In Page

**Files**:
- `src/app/(auth)/sign-in/page.tsx` (new)

**Complexity**: M (2h)

**Dependencies**: Phase 4 complete

**Description**:
Create sign-in page with email form that triggers Auth.js magic link flow.

**Implementation Steps**:
1. Create directory: `src/app/(auth)/sign-in/`
2. Create `page.tsx` Server Component (see spec Appendix)
3. Import `signIn` from Auth.js config
4. Import `emailSchema` from schemas
5. Create form with server action:
   - Email input field
   - Submit button "Send Magic Link"
6. Implement handleSignIn server action:
   - Get email from FormData
   - Validate with emailSchema.parse()
   - Call signIn('resend', { email, redirect: false })
7. Add Tailwind styling (centered form, responsive)
8. Add user-friendly messaging:
   - Heading: "Sign in to BigNight.Party"
   - Subtext: "We'll send you a magic link to sign in"

**Acceptance Criteria**:
- [ ] `/sign-in` page renders email form
- [ ] Form validates email format client-side (HTML5)
- [ ] Server action validates with Zod
- [ ] Magic link sent via Resend
- [ ] User-friendly error messages
- [ ] Responsive design with Tailwind

**Mandatory Patterns** (BigNight.Party):
- Server Components for data fetching
- Server actions for mutations
- Zod validation before submission
- **TDD**: E2E test for sign-in flow (future)

**Quality Gates**:
```bash
pnpm biome check --write src/app/
pnpm build                        # Builds successfully
pnpm dev                          # Page renders without errors
```

### Task 5.2: Create Route Protection Middleware

**Files**:
- `src/middleware.ts` (new)

**Complexity**: M (2h)

**Dependencies**: Phase 3 complete (Auth.js config exists)

**Description**:
Create middleware to protect routes and redirect unauthenticated users.

**Implementation Steps**:
1. Create `src/middleware.ts` at root (see spec Appendix)
2. Import `auth` from Auth.js config
3. Export middleware function wrapped with auth()
4. Implement logic:
   - Check if authenticated: `!!req.auth`
   - Check if on auth page: `/sign-in`
   - Check if on protected route: `/picks`, `/leaderboard`, `/dashboard`, `/admin`
5. Add redirect logic:
   - Protected route + not authenticated → redirect to `/sign-in`
   - Auth page + authenticated → redirect to `/dashboard`
6. Export config with matcher:
   ```typescript
   export const config = {
     matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)']
   }
   ```
7. Test redirects manually

**Acceptance Criteria**:
- [ ] Protects `/picks`, `/leaderboard`, `/dashboard`, `/admin` routes
- [ ] Redirects unauthenticated users to `/sign-in`
- [ ] Allows authenticated users to access protected routes
- [ ] Redirects authenticated users away from `/sign-in`
- [ ] Middleware runs on all routes (per matcher)

**Mandatory Patterns** (BigNight.Party):
- Middleware at root level (architecture.md)
- Auth checks on every request
- **TDD**: Integration test for middleware (future)

**Quality Gates**:
```bash
pnpm biome check --write src/middleware.ts
pnpm build                        # No errors
# Manual test: Visit protected route while logged out
```

---

## Phase 6: Verification & Testing

**Strategy**: Sequential
**Reason**: Depends on Phase 5 (all features implemented)

### Task 6.1: Manual Testing Checklist

**Files**:
- None (testing only)

**Complexity**: M (2h)

**Dependencies**: Phase 5 complete

**Description**:
Comprehensive manual testing of entire authentication flow.

**Implementation Steps**:
1. **Database Connection Tests**:
   - Run `docker ps` - verify PostgreSQL container running
   - Run `pnpm prisma studio` - verify can connect and see tables
   - Check tables exist: User, Account, VerificationToken
2. **Auth Flow Tests**:
   - Navigate to http://localhost:3000/sign-in
   - Enter email, submit form
   - Check Resend dashboard (https://resend.com/emails) for sent email
   - Click magic link in email
   - Verify redirected to `/dashboard`
   - Open DevTools → Application → Cookies
   - Verify session cookie present
3. **Session & Protection Tests**:
   - Visit protected route (e.g., `/dashboard`) - should work
   - Sign out (if sign-out UI exists, or clear cookies manually)
   - Visit protected route again - should redirect to `/sign-in`
4. **Role Assignment Tests**:
   - Sign in with email from ADMIN_EMAILS env var
   - Check JWT payload (decode cookie) - role should be ADMIN
   - Sign in with different email
   - Check JWT payload - role should be USER
5. **Prisma Verification**:
   - Open Prisma Studio: `pnpm prisma studio`
   - Check User table - record created with correct email
   - Check VerificationToken table - token created then deleted after use
6. **Build Verification**:
   - Run `pnpm build` - should complete without errors
   - Run `pnpm lint` - Biome should pass
   - Run `pnpm dev` - app should start

**Acceptance Criteria**:
- [ ] All database connection tests pass
- [ ] All auth flow tests pass
- [ ] All session & protection tests pass
- [ ] All role assignment tests pass
- [ ] All Prisma verification tests pass
- [ ] Build and lint commands succeed

**Mandatory Patterns** (BigNight.Party):
- Follow testing.md for manual verification
- Document any issues found
- **TDD**: Create automated tests based on manual tests (future)

**Quality Gates**:
```bash
docker ps                         # Container running
pnpm prisma studio                # Opens successfully
pnpm build                        # Success
pnpm lint                         # No errors
```

---

## Summary

### Task Complexity Breakdown
- **S Tasks** (1-2h): 7 tasks
- **M Tasks** (2-4h): 9 tasks
- **Total Estimated Time**: 8-10 hours

### Phase Dependencies
All phases are **sequential** - each phase depends on the previous:
1. **Phase 1** (Database Infrastructure) → Foundation
2. **Phase 2** (Prisma Setup) → Requires Phase 1
3. **Phase 3** (Auth.js Configuration) → Requires Phase 2
4. **Phase 4** (Server Actions & Validation) → Requires Phase 3
5. **Phase 5** (UI & Middleware) → Requires Phase 4
6. **Phase 6** (Verification) → Requires Phase 5

### No Parallelization Opportunities
Due to the layered dependencies (Database → ORM → Auth → Actions → UI), tasks cannot be parallelized. Each layer must be complete and tested before building the next.

### Critical Path
The entire implementation is on the critical path. Any delays in early phases (especially database and Prisma setup) will cascade to later phases.

### Risk Mitigation
- **Phase 1 & 2**: Most critical - verify database connection before proceeding
- **Phase 3**: Auth.js beta version may have breaking changes - pin version
- **Phase 4**: Server actions must follow patterns.md exactly
- **Phase 6**: Thorough testing prevents issues in future features

---

## Next Steps

### Review This Plan
```bash
cat specs/database-auth-setup/plan.md
```

### Execute Plan
```bash
/execute @specs/database-auth-setup/plan.md
```

### Modify Plan (if needed)
Edit this file directly, then run `/execute`.

---

**End of Implementation Plan**
