---
runId: b7645b
feature: refactor-admin-forms
created: 2025-01-01
status: ready
---

# Feature: Refactor Admin Forms - Implementation Plan

> **Generated by:** Task Decomposition skill
> **From spec:** specs/b7645b-refactor-admin-forms/spec.md
> **Created:** 2025-01-01

## Execution Summary

- **Total Tasks**: 9
- **Total Phases**: 4
- **Sequential Time**: 40h
- **Parallel Time**: 20h
- **Time Savings**: 20h (50% faster)

**Parallel Opportunities:**

- Phase 3: 6 tasks (24h → 5h, saves 19h)

**Migration Strategy:**

This plan follows a **Pattern-Layer Migration** approach:
1. **Layer 1**: Standardize all schemas to wire format (foundation)
2. **Layer 2**: Add transformation layer in routers (API boundary)
3. **Layer 3**: Migrate all forms to React Hook Form + oRPC (UI layer, parallel by domain)
4. **Layer 4**: Document patterns in constitution (mandatory standards)

---

## Phase 1: Schema Foundation

**Strategy**: Sequential
**Reason**: Foundation layer - all other layers depend on wire format schemas

### Task 1: Schema Standardization - Convert All Schemas to Wire Format

**Files**:
- src/schemas/event-schema.ts
- src/schemas/category-schema.ts
- src/schemas/nomination-schema.ts
- src/schemas/person-schema.ts
- src/schemas/work-schema.ts
- src/schemas/game-schema.ts (verify only, already compliant)

**Complexity**: M (4h)

**Dependencies**: None

**Description**:

Convert all admin schemas from backend format (using `.coerce.date()` and `.nativeEnum()`) to wire format (JSON-serializable types using `z.string().datetime()` and `z.enum([])`). This establishes a single source of truth for validation that works identically in forms, contracts, and routers.

**Implementation Steps**:

1. **Event Schema** (src/schemas/event-schema.ts):
   - Change `eventDate: z.coerce.date()` → `eventDate: z.string().datetime()`
   - Verify slug validation remains unchanged
   - Update both `eventCreateSchema` and `eventUpdateSchema`

2. **Work Schema** (src/schemas/work-schema.ts):
   - Change `type: z.nativeEnum(WorkType)` → `type: z.enum(["FILM", "TV_SHOW", "ALBUM", "OTHER"])`
   - Keep year validation logic unchanged
   - Update both `workCreateSchema` and `workUpdateSchema`

3. **Category Schema** (src/schemas/category-schema.ts):
   - Remove `.default(false)` from `isRevealed` (defaults set in router/service)
   - Remove `.default(1)` from `points`
   - Verify no date/enum fields (already wire format compatible)

4. **Nomination Schema** (src/schemas/nomination-schema.ts):
   - Verify no date/enum fields (already wire format compatible)
   - No changes needed, verification only

5. **Person Schema** (src/schemas/person-schema.ts):
   - Verify no date/enum fields (already wire format compatible)
   - No changes needed, verification only

6. **Game Schema** (src/schemas/game-schema.ts):
   - Verify already uses wire format for reference
   - Document as reference implementation
   - Note: Currently uses `.coerce.date()` and `.nativeEnum()` - needs conversion too!
   - Change `picksLockAt: z.coerce.date()` → `picksLockAt: z.string().datetime()`
   - Change `status: z.nativeEnum(GameStatus)` → `status: z.enum(["SETUP", "OPEN", "LIVE", "COMPLETED"])`
   - Remove `.default(GameStatus.SETUP)` from status

**Acceptance Criteria**:

- [ ] All date fields use `z.string().datetime()` (no `.coerce.date()`)
- [ ] All enum fields use `z.enum([...])` with string literals (no `.nativeEnum()`)
- [ ] All schemas export both schema object and inferred type
- [ ] No `.default()` calls in schemas (defaults will be set in router/service layer)
- [ ] TypeScript compiles without errors
- [ ] All admin forms still validate correctly (behavior unchanged at form level)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- **Wire Format**: Use JSON-serializable types (strings for dates, string literals for enums)
- **No Defaults**: Remove `.default()` from schemas - set defaults in router or service layer
- **Type Exports**: Always export both schema and inferred type (e.g., `EventCreateInput`)

**Quality Gates**:

```bash
pnpm biome check --write .
pnpm lint
pnpm build
```

---

## Phase 2: Router Transformation Layer

**Strategy**: Sequential
**Reason**: Depends on Phase 1 (wire schemas), blocks Phase 3 (forms call routers)

### Task 2: Router Transformation - Add Wire-to-Domain Transformation

**Files**:
- src/lib/api/routers/admin.ts
- src/lib/api/utils/wire-to-domain.ts (create if doesn't exist)

**Complexity**: M (4h)

**Dependencies**: Task 1 (requires wire format schemas)

**Description**:

Add wire-to-domain transformation layer in all admin router handlers. This transforms wire format (strings, string literals) into domain types (Date objects, enums) at the API boundary before calling services. Services continue to receive clean domain types with no changes needed.

**Implementation Steps**:

1. **Create Wire-to-Domain Utilities** (if not exists):
   ```typescript
   // src/lib/api/utils/wire-to-domain.ts
   export function parseDate(dateString: string): Date {
     return new Date(dateString);
   }

   export function parseOptionalDate(dateString: string | undefined): Date | undefined {
     return dateString ? new Date(dateString) : undefined;
   }

   export function parseOptionalDateOrNull(dateString: string | undefined): Date | null {
     return dateString ? new Date(dateString) : null;
   }
   ```

2. **Transform Events Router** (src/lib/api/routers/admin.ts):
   ```typescript
   events: {
     create: os.events.create.use(adminMiddleware).handler(async ({ input }) => {
       const { eventDate, ...data } = input;
       const event = await eventService.createEvent({
         ...data,
         eventDate: parseDate(eventDate), // Transform wire → domain
       });
       return event;
     }),
     update: os.events.update.use(adminMiddleware).handler(async ({ input }) => {
       const { id, eventDate, ...data } = input;
       const event = await eventService.updateEvent(id, {
         ...data,
         eventDate: eventDate ? parseDate(eventDate) : undefined,
       });
       return event;
     }),
   }
   ```

3. **Transform Games Router**:
   ```typescript
   games: {
     create: os.games.create.use(adminMiddleware).handler(async ({ input }) => {
       const { picksLockAt, status, ...data } = input;
       const game = await gameService.createGame({
         ...data,
         picksLockAt: parseOptionalDate(picksLockAt),
         status: status as GameStatus, // String literal → enum
       });
       return game;
     }),
     update: os.games.update.use(adminMiddleware).handler(async ({ input }) => {
       const { id, picksLockAt, status, ...data } = input;
       const game = await gameService.updateGame(id, {
         ...data,
         picksLockAt: picksLockAt ? parseOptionalDate(picksLockAt) : undefined,
         status: status ? (status as GameStatus) : undefined,
       });
       return game;
     }),
   }
   ```

4. **Transform Works Router**:
   ```typescript
   works: {
     create: os.works.create.use(adminMiddleware).handler(async ({ input }) => {
       const { type, ...data } = input;
       const work = await workModel.create({
         ...data,
         type: type as WorkType, // String literal → enum
       });
       return work;
     }),
     update: os.works.update.use(adminMiddleware).handler(async ({ input }) => {
       const { id, type, ...data } = input;
       const work = await workModel.update(id, {
         ...data,
         type: type ? (type as WorkType) : undefined,
       });
       return work;
     }),
   }
   ```

5. **Verify No Transformation Needed**:
   - Categories: No date/enum fields
   - Nominations: No date/enum fields
   - People: No date/enum fields

**Acceptance Criteria**:

- [ ] All routers import and use wire-to-domain utilities for date transformation
- [ ] All enum fields cast from string literals to domain enums at router boundary
- [ ] Services receive unchanged domain types (Date objects, Prisma enums)
- [ ] Service signatures remain unchanged (no breaking changes)
- [ ] All handlers destructure wire fields before transformation
- [ ] TypeScript compiles without errors
- [ ] All admin mutations work identically to before (behavior unchanged)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- **API Boundary Transformation**: Transform wire → domain at router layer, never in services
- **Destructure Before Transform**: Always destructure input fields before transformation
- **Service Isolation**: Services remain unaware of wire format (domain types only)

**Quality Gates**:

```bash
pnpm biome check --write .
pnpm lint
pnpm build
```

---

## Phase 3: Form Component Migration (Parallel by Domain)

**Strategy**: Parallel
**Reason**: All tasks in this phase are independent (different domains), can execute concurrently

### Task 3: Events Forms - Extract to React Hook Form + oRPC

**Files**:
- src/components/admin/events/create-event-form.tsx (create)
- src/components/admin/events/edit-event-form.tsx (create)
- src/app/(admin)/admin/events/new/page.tsx (simplify)
- src/app/(admin)/admin/events/[id]/page.tsx (simplify)

**Complexity**: M (5h)

**Dependencies**: Task 1, Task 2 (requires wire schemas and router endpoints)

**Description**:

Extract event forms from Server Components to Client Components using React Hook Form with zodResolver and oRPC mutations. Pages become simple Server Components that fetch data and render form components.

**Implementation Steps**:

1. **Create CreateEventForm** (src/components/admin/events/create-event-form.tsx):
   ```typescript
   "use client";

   import { zodResolver } from "@hookform/resolvers/zod";
   import { useRouter } from "next/navigation";
   import { useForm } from "react-hook-form";
   import { useMutation } from "@tanstack/react-query";
   import { orpc } from "@/lib/api/client";
   import { eventCreateSchema } from "@/schemas/event-schema";
   import { routes } from "@/lib/routes";

   export function CreateEventForm() {
     const router = useRouter();
     const form = useForm({
       resolver: zodResolver(eventCreateSchema),
       defaultValues: { name: "", slug: "", eventDate: "", description: "" },
     });

     const mutation = useMutation(
       orpc.admin.events.create.mutationOptions()
     );

     const onSubmit = async (data) => {
       const result = await mutation.mutateAsync(data);
       router.push(routes.admin.events.detail(result.id));
     };

     return (
       <AdminForm
         form={form}
         onSubmit={onSubmit}
         isLoading={mutation.isPending}
         error={mutation.error?.message}
       >
         {/* Form fields using FormFieldGroup */}
       </AdminForm>
     );
   }
   ```

2. **Create EditEventForm** (src/components/admin/events/edit-event-form.tsx):
   - Similar structure to CreateEventForm
   - Use `eventUpdateSchema` and `orpc.admin.events.update`
   - Pass initial data as defaultValues
   - No redirect on success (inline update)

3. **Simplify Create Page** (src/app/(admin)/admin/events/new/page.tsx):
   ```typescript
   import { CreateEventForm } from "@/components/admin/events/create-event-form";

   export default async function NewEventPage() {
     return (
       <div>
         <h1>Create New Event</h1>
         <CreateEventForm />
       </div>
     );
   }
   ```

4. **Simplify Edit Page** (src/app/(admin)/admin/events/[id]/page.tsx):
   - Keep Server Component for data fetching
   - Render EditEventForm with event data
   - Keep delete handler as standalone Server Action

**Acceptance Criteria**:

- [ ] CreateEventForm uses React Hook Form with zodResolver(eventCreateSchema)
- [ ] EditEventForm uses React Hook Form with zodResolver(eventUpdateSchema)
- [ ] Both forms use oRPC mutations via useMutation(orpc.admin.events.*.mutationOptions())
- [ ] Forms display field-level validation errors
- [ ] Forms display mutation errors in error banner
- [ ] Forms show loading states (disabled submit button)
- [ ] Pages remain Server Components (async functions)
- [ ] Create page redirects to detail page on success
- [ ] Edit page updates inline (no redirect)
- [ ] Forms match styling of reference implementation (games/new)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- **Client Component Forms**: All forms must be Client Components with "use client"
- **React Hook Form**: Use zodResolver with wire format schema
- **oRPC Mutations**: Use useMutation(orpc.*.mutationOptions()), never call orpc.*.useMutation()
- **Server Component Pages**: Pages remain Server Components for data fetching
- **Centralized Routes**: Use routes from @/lib/routes for all navigation

**Quality Gates**:

```bash
pnpm biome check --write .
pnpm lint
pnpm build
```

---

### Task 4: Categories Forms - Extract to React Hook Form + oRPC

**Files**:
- src/components/admin/categories/create-category-form.tsx (create)
- src/components/admin/categories/edit-category-form.tsx (create)
- src/app/(admin)/admin/events/[id]/categories/new/page.tsx (simplify)
- src/app/(admin)/admin/events/[id]/categories/[categoryId]/page.tsx (simplify)

**Complexity**: M (5h)

**Dependencies**: Task 1, Task 2 (requires wire schemas and router endpoints)

**Description**:

Extract category forms from Server Components to Client Components using React Hook Form with zodResolver and oRPC mutations. Follow same pattern as Task 3 (Events).

**Implementation Steps**:

1. Create CreateCategoryForm component
2. Create EditCategoryForm component
3. Simplify create page to render form component
4. Simplify edit page to render form component (keep delete handler)

**Acceptance Criteria**:

- [ ] CreateCategoryForm uses React Hook Form with zodResolver(categoryCreateSchema)
- [ ] EditCategoryForm uses React Hook Form with zodResolver(categoryUpdateSchema)
- [ ] Both forms use oRPC mutations via useMutation(orpc.admin.categories.*.mutationOptions())
- [ ] Forms display field-level validation errors
- [ ] Forms display mutation errors in error banner
- [ ] Forms show loading states
- [ ] Pages remain Server Components
- [ ] Forms match styling of reference implementation

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Same patterns as Task 3 (Events).

**Quality Gates**:

```bash
pnpm biome check --write .
pnpm lint
pnpm build
```

---

### Task 5: Nominations Forms - Extract to React Hook Form + oRPC

**Files**:
- src/components/admin/nominations/create-nomination-form.tsx (create)
- src/components/admin/nominations/edit-nomination-form.tsx (create)
- src/app/(admin)/admin/events/[id]/categories/[categoryId]/nominations/new/page.tsx (simplify)
- src/app/(admin)/admin/events/[id]/categories/[categoryId]/nominations/[nominationId]/page.tsx (simplify, if exists)

**Complexity**: M (5h)

**Dependencies**: Task 1, Task 2 (requires wire schemas and router endpoints)

**Description**:

Extract nomination forms from Server Components to Client Components using React Hook Form with zodResolver and oRPC mutations. Follow same pattern as Task 3 (Events).

**Implementation Steps**:

1. Create CreateNominationForm component
2. Create EditNominationForm component (if edit page exists)
3. Simplify create page to render form component
4. Simplify edit page to render form component (if exists)

**Acceptance Criteria**:

- [ ] CreateNominationForm uses React Hook Form with zodResolver(nominationCreateSchema)
- [ ] EditNominationForm uses React Hook Form with zodResolver(nominationUpdateSchema) (if applicable)
- [ ] Both forms use oRPC mutations via useMutation(orpc.admin.nominations.*.mutationOptions())
- [ ] Forms display field-level validation errors
- [ ] Forms display mutation errors in error banner
- [ ] Forms show loading states
- [ ] Pages remain Server Components
- [ ] Forms match styling of reference implementation

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Same patterns as Task 3 (Events).

**Quality Gates**:

```bash
pnpm biome check --write .
pnpm lint
pnpm build
```

---

### Task 6: People Forms - Extract to React Hook Form + oRPC

**Files**:
- src/components/admin/people/create-person-form.tsx (create)
- src/components/admin/people/edit-person-form.tsx (create)
- src/app/(admin)/admin/people/new/page.tsx (simplify)
- src/app/(admin)/admin/people/[id]/page.tsx (simplify)

**Complexity**: M (5h)

**Dependencies**: Task 1, Task 2 (requires wire schemas and router endpoints)

**Description**:

Extract person forms from Server Components to Client Components using React Hook Form with zodResolver and oRPC mutations. Follow same pattern as Task 3 (Events).

**Implementation Steps**:

1. Create CreatePersonForm component
2. Create EditPersonForm component
3. Simplify create page to render form component
4. Simplify edit page to render form component (keep delete handler)

**Acceptance Criteria**:

- [ ] CreatePersonForm uses React Hook Form with zodResolver(personCreateSchema)
- [ ] EditPersonForm uses React Hook Form with zodResolver(personUpdateSchema)
- [ ] Both forms use oRPC mutations via useMutation(orpc.admin.people.*.mutationOptions())
- [ ] Forms display field-level validation errors
- [ ] Forms display mutation errors in error banner
- [ ] Forms show loading states
- [ ] Pages remain Server Components
- [ ] Forms match styling of reference implementation

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Same patterns as Task 3 (Events).

**Quality Gates**:

```bash
pnpm biome check --write .
pnpm lint
pnpm build
```

---

### Task 7: Works Forms - Extract to React Hook Form + oRPC

**Files**:
- src/components/admin/works/create-work-form.tsx (create)
- src/components/admin/works/edit-work-form.tsx (create)
- src/app/(admin)/admin/works/new/page.tsx (simplify)
- src/app/(admin)/admin/works/[id]/page.tsx (simplify)

**Complexity**: M (5h)

**Dependencies**: Task 1, Task 2 (requires wire schemas and router endpoints)

**Description**:

Extract work forms from Server Components to Client Components using React Hook Form with zodResolver and oRPC mutations. Follow same pattern as Task 3 (Events). Note: Work type enum was converted to string literals in Task 1.

**Implementation Steps**:

1. Create CreateWorkForm component
2. Create EditWorkForm component
3. Simplify create page to render form component
4. Simplify edit page to render form component (keep delete handler)

**Acceptance Criteria**:

- [ ] CreateWorkForm uses React Hook Form with zodResolver(workCreateSchema)
- [ ] EditWorkForm uses React Hook Form with zodResolver(workUpdateSchema)
- [ ] Both forms use oRPC mutations via useMutation(orpc.admin.works.*.mutationOptions())
- [ ] Work type dropdown uses string literals from wire schema (not Prisma enum)
- [ ] Forms display field-level validation errors
- [ ] Forms display mutation errors in error banner
- [ ] Forms show loading states
- [ ] Pages remain Server Components
- [ ] Forms match styling of reference implementation

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Same patterns as Task 3 (Events).

**Quality Gates**:

```bash
pnpm biome check --write .
pnpm lint
pnpm build
```

---

### Task 8: Games Edit Form - Extract to React Hook Form + oRPC

**Files**:
- src/components/admin/games/edit-game-form.tsx (create)
- src/app/(admin)/admin/games/[id]/page.tsx (simplify)

**Complexity**: S (2h)

**Dependencies**: Task 1, Task 2 (requires wire schemas and router endpoints)

**Description**:

Extract game edit form from Server Component to Client Component using React Hook Form with zodResolver and oRPC mutation. The create form already exists and follows the correct pattern, so only the edit form needs migration.

**Implementation Steps**:

1. Create EditGameForm component (based on existing GameForm from games/new)
2. Simplify edit page to render form component (keep delete handler)
3. Verify create form still works (already follows correct pattern)

**Acceptance Criteria**:

- [ ] EditGameForm uses React Hook Form with zodResolver(gameUpdateSchema)
- [ ] Form uses oRPC mutation via useMutation(orpc.admin.games.update.mutationOptions())
- [ ] Form displays field-level validation errors
- [ ] Form displays mutation errors in error banner
- [ ] Form shows loading states
- [ ] Edit page remains Server Component
- [ ] Create form (games/new) still works correctly (no changes needed)
- [ ] Form matches styling of reference implementation

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

Same patterns as Task 3 (Events).

**Quality Gates**:

```bash
pnpm biome check --write .
pnpm lint
pnpm build
```

---

## Phase 4: Documentation

**Strategy**: Sequential
**Reason**: Documents completed implementation patterns, should be done after Phase 3

### Task 9: Constitution Update - Document Mandatory Patterns

**Files**:
- docs/constitutions/current/patterns.md

**Complexity**: S (2h)

**Dependencies**: Task 3, Task 4, Task 5, Task 6, Task 7, Task 8 (documents completed implementation)

**Description**:

Add two new sections to the constitution documenting the wire-to-domain pattern and admin form pattern as mandatory for all admin forms. Reference existing documentation files for complete details.

**Implementation Steps**:

1. **Add Wire-to-Domain Pattern Section**:
   ```markdown
   ## Wire-to-Domain Pattern (MANDATORY for Admin Forms)

   **Purpose**: Separate wire format (JSON-serializable) from domain types (Date, enums) for type-safe API contracts.

   **Pattern**:
   - Schemas use wire format (z.string().datetime(), z.enum([...]))
   - Routers transform wire → domain at API boundary
   - Services receive clean domain types (unchanged)

   **Why**: Single source of truth for validation (forms, contracts, routers), no coercion confusion

   **See**: @docs/wire-to-domain-pattern.md for complete details
   ```

2. **Add Admin Form Pattern Section**:
   ```markdown
   ## Admin Form Pattern (MANDATORY for Admin Forms)

   **Purpose**: Consistent, type-safe form pattern with real-time validation and error handling.

   **Pattern**:
   - Forms are Client Components with React Hook Form + zodResolver
   - Forms use oRPC mutations with useMutation(orpc.*.mutationOptions())
   - Pages are Server Components that render form components
   - No inline Server Actions (use oRPC endpoints)

   **Why**: Real-time validation, loading states, error handling, type safety from schema → router → service

   **See**: @docs/admin-form-pattern.md for complete details
   ```

3. **Update Code Review Checklist** (in patterns.md):
   - Add wire-to-domain pattern verification
   - Add admin form pattern verification
   - Add checks for no inline Server Actions in admin forms

4. **Verify References**:
   - Ensure docs/wire-to-domain-pattern.md exists and is accurate
   - Ensure docs/admin-form-pattern.md exists and is accurate
   - Update references if documentation location changes

**Acceptance Criteria**:

- [ ] Wire-to-domain pattern section added to patterns.md
- [ ] Admin form pattern section added to patterns.md
- [ ] Both patterns marked as MANDATORY for admin forms
- [ ] Sections reference existing documentation files for complete details
- [ ] Code review checklist updated to include both patterns
- [ ] All documentation is clear, concise, and actionable
- [ ] Markdown formatting is correct (no broken links)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- **Documentation Quality**: Clear, concise, with rationale (why, not just what)
- **References**: Link to detailed docs instead of duplicating content
- **Mandatory Markers**: Clearly mark patterns as MANDATORY vs recommended

**Quality Gates**:

```bash
# Verify markdown formatting
pnpm biome check --write .
# Verify links work
ls docs/wire-to-domain-pattern.md
ls docs/admin-form-pattern.md
```

---

## Summary

This plan implements a systematic migration from Server Actions with FormData to React Hook Form with oRPC mutations across all admin forms. The layered approach ensures:

1. **Layer 1** establishes wire format foundation
2. **Layer 2** adds transformation boundary at router layer
3. **Layer 3** migrates all forms independently (can parallelize)
4. **Layer 4** documents patterns as mandatory standards

**Key Benefits**:
- **Type Safety**: Full type inference from schema → router → service
- **Validation**: Real-time validation in all forms
- **UX**: Loading states, error handling, no double-submit
- **Consistency**: All forms follow identical pattern
- **Maintainability**: Single source of truth for validation logic

**Execution Time**:
- **Sequential**: 40 hours (all tasks in order)
- **With Parallelization**: 20 hours (Phase 3 runs in parallel)
- **Time Savings**: 50% reduction through parallel execution
