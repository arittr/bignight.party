---
runId: 10465d
feature: live-ceremony-core-loop
created: 2025-11-12
status: ready
---

# Live Ceremony Core Loop - Implementation Plan

> **Generated by:** Task Decomposition skill
> **From spec:** specs/10465d-live-ceremony-core-loop/spec.md
> **Created:** 2025-11-12

## Execution Summary

- **Total Tasks**: 6
- **Total Phases**: 4
- **Sequential Time**: 29h
- **Parallel Time**: 22h
- **Time Savings**: 7h (24% faster)

**Parallel Opportunities:**

- Phase 2: 2 tasks (7h saved - WebSocket events and oRPC contracts are independent)

---

## Phase 1: Data Layer Foundation

**Strategy**: Sequential
**Reason**: Single coherent task establishing all model and service methods

### Task 1.1: Data Layer - Models and Service Orchestration

**Files**:
- src/lib/models/pick.ts
- src/lib/models/category.ts
- src/lib/models/game.ts
- src/lib/services/category-service.ts
- src/lib/services/game-service.ts

**Complexity**: M (4h)

**Dependencies**: None

**Description**:
Implement all data access methods and business logic orchestration for live winner marking and automatic game completion. This task adds model methods for pick aggregation and game state queries, plus service methods that coordinate multi-step operations including winner marking, leaderboard updates, and game completion.

**Implementation Steps**:

1. **Add pick model methods** (`src/lib/models/pick.ts`):
   - `getPickCountsForGame(gameId: string)`: Aggregate pick counts across all categories
     - Use Prisma `groupBy` with `by: ['categoryId', 'nominationId']`
     - Return array: `{ categoryId, nominationId, count }[]`
   - `areAllCategoriesRevealed(gameId: string)`: Check completion status
     - Query game with categories, check `every(cat => cat.isRevealed === true)`
     - Return boolean

2. **Add category model methods** (`src/lib/models/category.ts`):
   - `markWinner(categoryId, nominationId)`: Atomic update
     - Use `categoryModel.update()` to set `{ isRevealed: true, winnerNominationId }`
   - `clearWinner(categoryId)`: Atomic unreveal
     - Use `categoryModel.update()` to set `{ isRevealed: false, winnerNominationId: null }`

3. **Add game model method** (`src/lib/models/game.ts`):
   - `completeGame(gameId)`: Status transition
     - Use `gameModel.update()` to set `{ status: 'COMPLETED', completedAt: new Date() }`

4. **Update category service** (`src/lib/services/category-service.ts`):
   - Modify existing `markWinner()` to call new orchestration:
     ```typescript
     export async function markWinnerAndUpdate(categoryId: string, nominationId: string, gameId: string) {
       // 1. Mark winner (existing logic)
       await categoryModel.markWinner(categoryId, nominationId)

       // 2. Broadcast leaderboard update (existing logic)
       const category = await categoryModel.findById(categoryId)
       const games = await gameModel.findByEventId(category.eventId)
       for (const game of games) {
         leaderboardService.broadcastLeaderboardUpdate(game.id).catch(...)
       }

       // 3. NEW: Check if game should complete
       const allRevealed = await pickModel.areAllCategoriesRevealed(gameId)
       if (allRevealed) {
         await gameService.completeGame(gameId)
       }
     }
     ```

5. **Add game service method** (`src/lib/services/game-service.ts`):
   - `completeGame(gameId)`: Orchestrate completion
     ```typescript
     export async function completeGame(gameId: string) {
       // 1. Verify game is LIVE
       const game = await gameModel.findById(gameId)
       if (game.status !== 'LIVE') {
         throw new Error('Game must be LIVE to complete')
       }

       // 2. Update status
       await gameModel.completeGame(gameId)

       // 3. Broadcast completion event (added in Phase 2)
       // emitGameCompleted(gameId, { gameId, completedAt: new Date().toISOString() })
     }
     ```

**Acceptance Criteria**:

- [ ] `getPickCountsForGame()` returns correct aggregated counts for all categories
- [ ] `areAllCategoriesRevealed()` returns true only when ALL categories have `isRevealed = true`
- [ ] `markWinner()` atomically sets both `isRevealed` and `winnerNominationId`
- [ ] `clearWinner()` atomically unsets both fields
- [ ] `completeGame()` transitions game status and sets `completedAt`
- [ ] `markWinnerAndUpdate()` triggers game completion when last category revealed
- [ ] `markWinnerAndUpdate()` does NOT trigger completion if categories remain unrevealed
- [ ] All model methods have proper TypeScript return types
- [ ] Service methods handle errors gracefully (log, don't throw)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- **Layer boundaries**: Models ONLY query Prisma, Services orchestrate business logic
- **No Prisma in services**: Services call models, never import `@prisma/client`
- **ts-pattern**: Use for GameStatus checks (`.with('LIVE', ...)`)
- **Error handling**: Service layer catches errors, logs, continues (leaderboard broadcast pattern)

**TDD**: Follow `test-driven-development` skill

**Quality Gates**:
```bash
pnpm biome check --write .
pnpm test src/lib/models/pick.test.ts
pnpm test src/lib/models/category.test.ts
pnpm test src/lib/models/game.test.ts
pnpm test src/lib/services/category-service.test.ts
pnpm test src/lib/services/game-service.test.ts
```

---

## Phase 2: WebSocket Events and oRPC Contracts

**Strategy**: Parallel
**Reason**: WebSocket events and oRPC contract extensions are independent

### Task 2.1: WebSocket Events - Game Completion

**Files**:
- src/lib/websocket/events.ts
- src/lib/websocket/server.ts
- src/types/leaderboard.ts

**Complexity**: S (2h)

**Dependencies**: None (standalone WebSocket infrastructure)

**Description**:
Add `GAME_COMPLETED` WebSocket event definition and server emission function. This event notifies all connected clients when a game transitions to COMPLETED status, enabling real-time UI updates without page refresh.

**Implementation Steps**:

1. **Define event constant** (`src/lib/websocket/events.ts`):
   ```typescript
   export const LEADERBOARD_EVENTS = {
     // ... existing events
     // biome-ignore lint/style/useNamingConvention: UPPER_CASE is correct for constant event names
     GAME_COMPLETED: "game:completed",
   } as const;
   ```

2. **Define payload type** (`src/types/leaderboard.ts`):
   ```typescript
   export interface GameCompletedPayload {
     gameId: string;
     completedAt: string; // ISO 8601 timestamp
   }
   ```

3. **Add emission function** (`src/lib/websocket/server.ts`):
   ```typescript
   export function emitGameCompleted(gameId: string, payload: GameCompletedPayload): void {
     if (!io) {
       console.warn("[WebSocket] Cannot emit game completed - server not initialized");
       return;
     }

     io.to(gameId).emit(LEADERBOARD_EVENTS.GAME_COMPLETED, payload);
     console.log(`[WebSocket] Emitted game completed to game ${gameId}`);
   }
   ```

4. **Update service to emit** (`src/lib/services/game-service.ts`):
   - Import `emitGameCompleted` from `@/lib/websocket/server`
   - Call after `gameModel.completeGame()` in `completeGame()` method

**Acceptance Criteria**:

- [ ] `GAME_COMPLETED` constant exported from events.ts
- [ ] `GameCompletedPayload` type defined with gameId and ISO timestamp
- [ ] `emitGameCompleted()` broadcasts to correct game room
- [ ] Function handles uninitialized server gracefully (logs warning)
- [ ] `gameService.completeGame()` calls `emitGameCompleted()` after status update
- [ ] TypeScript types are properly exported and imported

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- **WebSocket pattern**: Services emit events, NOT actions
- **Error handling**: Graceful degradation if WebSocket unavailable
- **Logging**: Use console for WebSocket debugging (allowed per existing pattern)

**Quality Gates**:
```bash
pnpm biome check --write .
pnpm test src/lib/websocket/server.test.ts
```

### Task 2.2: oRPC Contracts - Add gameId Parameter

**Files**:
- src/lib/api/contracts/admin.ts
- src/lib/api/routers/admin.ts

**Complexity**: M (3h)

**Dependencies**: None (extends existing admin contracts)

**Description**:
Extend existing `markWinner` and `clearWinner` oRPC contracts to include `gameId` parameter. This enables the service layer to trigger game completion checks when winners are marked during live ceremony. Update router implementations to pass gameId to service methods.

**Implementation Steps**:

1. **Update markWinner contract** (`src/lib/api/contracts/admin.ts`):
   ```typescript
   export const markWinnerContract = oc
     .input(
       z.object({
         categoryId: z.string().cuid("Invalid category ID"),
         nominationId: z.string().cuid("Invalid nomination ID"),
         gameId: z.string().cuid("Invalid game ID"), // NEW
       })
     )
     .output(
       z.object({
         id: z.string(),
         name: z.string(),
         order: z.number(),
         points: z.number(),
         isRevealed: z.boolean(),
         winnerNominationId: z.string().nullable(),
         eventId: z.string(),
         createdAt: z.date(),
         updatedAt: z.date(),
       })
     );
   ```

2. **Update clearWinner contract** (`src/lib/api/contracts/admin.ts`):
   ```typescript
   export const clearWinnerContract = oc
     .input(
       z.object({
         categoryId: z.string().cuid("Invalid category ID"),
         gameId: z.string().cuid("Invalid game ID"), // NEW
       })
     )
     .output(
       z.object({
         id: z.string(),
         name: z.string(),
         order: z.number(),
         points: z.number(),
         isRevealed: z.boolean(),
         winnerNominationId: z.string().nullable(),
         eventId: z.string(),
         createdAt: z.date(),
         updatedAt: z.date(),
       })
     );
   ```

3. **Update router implementations** (`src/lib/api/routers/admin.ts`):
   ```typescript
   markWinner: os.categories.markWinner.use(adminMiddleware).handler(async ({ input }) => {
     const category = await categoryService.markWinnerAndUpdate(
       input.categoryId,
       input.nominationId,
       input.gameId // NEW
     );
     return category;
   }),

   clearWinner: os.categories.clearWinner.use(adminMiddleware).handler(async ({ input }) => {
     // Note: clearWinner doesn't trigger game completion check
     const category = await categoryService.clearWinner(input.categoryId);
     return category;
   }),
   ```

4. **Update service signature** (`src/lib/services/category-service.ts`):
   - Change `markWinnerAndUpdate()` signature to match new contract
   - Use gameId parameter for completion check (already implemented in Phase 1)

**Acceptance Criteria**:

- [ ] `markWinnerContract` includes required `gameId` parameter
- [ ] `clearWinnerContract` includes required `gameId` parameter
- [ ] Contract validation rejects invalid CUIDs for gameId
- [ ] Router passes gameId to `markWinnerAndUpdate()` service method
- [ ] Service uses gameId for game completion check
- [ ] TypeScript types flow correctly from contract → router → service
- [ ] Existing category edit pages continue to work (they don't need game completion)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- **oRPC contract-first**: ALWAYS use `oc.input().output()` pattern
- **implement(contract)**: Single implement() call for entire admin contract
- **Validation**: Use Zod schemas for all inputs (`.cuid()` for IDs)
- **Layer boundaries**: Router calls service, service calls models

**Quality Gates**:
```bash
pnpm biome check --write .
pnpm test src/lib/api/routers/admin.test.ts
```

---

## Phase 3: Admin Live Winner Marking UI

**Strategy**: Sequential
**Reason**: Single coherent UI layer with page and client component

### Task 3.1: Admin Live Winner Marking Page and Component

**Files**:
- src/app/(admin)/admin/games/[gameId]/live/page.tsx
- src/components/admin/games/live-category-card.tsx
- src/lib/routes.ts
- src/app/(admin)/admin/games/[gameId]/page.tsx

**Complexity**: L (7h)

**Dependencies**: Phase 1 (needs models for data fetching), Phase 2 (needs contracts for mutations)

**Description**:
Build admin interface for marking winners during live ceremony. Server Component page fetches game, event, categories, nominations, and pick counts in a single optimized query. Client Component card handles winner selection via oRPC mutation with optimistic updates. Includes route definition and navigation link from game detail page.

**Implementation Steps**:

1. **Add route definition** (`src/lib/routes.ts`):
   - Already exists: `admin.games.live(gameId)` at line 59
   - Verify it returns `/admin/games/${gameId}/live`

2. **Create Server Component page** (`src/app/(admin)/admin/games/[gameId]/live/page.tsx`):
   ```typescript
   import { requireValidatedSession } from "@/lib/auth/config";
   import { redirect } from "next/navigation";
   import { routes } from "@/lib/routes";
   import * as gameModel from "@/lib/models/game";
   import * as categoryModel from "@/lib/models/category";
   import * as pickModel from "@/lib/models/pick";
   import { LiveCategoryCard } from "@/components/admin/games/live-category-card";

   type Props = {
     params: Promise<{ gameId: string }>;
   };

   export default async function LiveWinnerMarkingPage({ params }: Props) {
     // Auth check
     const session = await requireValidatedSession();
     if (session.user.role !== 'ADMIN') {
       redirect(routes.dashboard());
     }

     // Await params (Next.js 15)
     const { gameId } = await params;

     // Fetch game with event
     const game = await gameModel.findById(gameId);
     if (!game) {
       redirect(routes.admin.games.index());
     }

     // Fetch categories with nominations (ordered by category.order)
     const categories = await categoryModel.findByEventId(game.eventId);

     // Fetch pick counts for all categories (single query, no N+1)
     const pickCounts = await pickModel.getPickCountsForGame(gameId);

     // Build pick count map for O(1) lookup
     const pickCountMap = pickCounts.reduce((acc, pc) => {
       const key = `${pc.categoryId}:${pc.nominationId}`;
       acc[key] = pc.count;
       return acc;
     }, {} as Record<string, number>);

     return (
       <div className="container mx-auto p-8">
         <div className="mb-8">
           <h1 className="text-3xl font-bold">{game.name}</h1>
           <p className="text-gray-600">{game.event.name}</p>
           <p className="text-sm text-gray-500">
             <a href={routes.admin.games.detail(gameId)}>← Back to game</a>
           </p>
         </div>

         <div className="space-y-6">
           {categories.map((category) => (
             <LiveCategoryCard
               key={category.id}
               category={category}
               gameId={gameId}
               pickCountMap={pickCountMap}
             />
           ))}
         </div>
       </div>
     );
   }
   ```

3. **Create Client Component card** (`src/components/admin/games/live-category-card.tsx`):
   ```typescript
   "use client";

   import { useState } from "react";
   import { useMutation } from "@tanstack/react-query";
   import { orpc } from "@/lib/api/client";
   import type { Category, Nomination } from "@prisma/client";

   type Props = {
     category: Category & { nominations: Nomination[] };
     gameId: string;
     pickCountMap: Record<string, number>;
   };

   export function LiveCategoryCard({ category, gameId, pickCountMap }: Props) {
     const [selectedNominationId, setSelectedNominationId] = useState<string | null>(
       category.winnerNominationId
     );

     const markWinnerMutation = useMutation(
       orpc.admin.categories.markWinner.mutationOptions()
     );

     const clearWinnerMutation = useMutation(
       orpc.admin.categories.clearWinner.mutationOptions()
     );

     const handleMarkWinner = async (nominationId: string) => {
       await markWinnerMutation.mutateAsync({
         categoryId: category.id,
         nominationId,
         gameId,
       });
       setSelectedNominationId(nominationId);
       window.location.reload(); // Refresh to show updated state
     };

     const handleClearWinner = async () => {
       await clearWinnerMutation.mutateAsync({
         categoryId: category.id,
         gameId,
       });
       setSelectedNominationId(null);
       window.location.reload();
     };

     return (
       <div className="border rounded-lg p-6 bg-white shadow">
         <div className="flex justify-between items-start mb-4">
           <div>
             <h2 className="text-xl font-semibold">{category.name}</h2>
             <p className="text-sm text-gray-600">{category.points} points</p>
           </div>
           {category.isRevealed && category.winnerNominationId && (
             <div className="flex items-center gap-2">
               <span className="text-green-600 font-semibold">✓ Revealed</span>
               <button
                 onClick={handleClearWinner}
                 className="text-sm text-red-600 hover:underline"
               >
                 Clear
               </button>
             </div>
           )}
         </div>

         <div className="space-y-2">
           {category.nominations.map((nomination) => {
             const key = `${category.id}:${nomination.id}`;
             const pickCount = pickCountMap[key] || 0;
             const isWinner = selectedNominationId === nomination.id;

             return (
               <button
                 key={nomination.id}
                 onClick={() => handleMarkWinner(nomination.id)}
                 className={`w-full text-left p-3 rounded border ${
                   isWinner
                     ? "border-green-500 bg-green-50"
                     : "border-gray-300 hover:bg-gray-50"
                 }`}
               >
                 <div className="flex justify-between items-center">
                   <span className={isWinner ? "font-semibold" : ""}>
                     {nomination.nominationText}
                   </span>
                   <span className="text-sm text-gray-600">
                     {pickCount} {pickCount === 1 ? "pick" : "picks"}
                   </span>
                 </div>
               </button>
             );
           })}
         </div>
       </div>
     );
   }
   ```

4. **Add navigation link** (`src/app/(admin)/admin/games/[gameId]/page.tsx`):
   - Add link: `<a href={routes.admin.games.live(gameId)}>Live Winner Marking</a>`
   - Position below "Edit Game" link, above status controls

**Acceptance Criteria**:

- [ ] Page loads at `/admin/games/{gameId}/live` for authenticated admins
- [ ] Non-admin users redirected to dashboard
- [ ] Page shows game name, event name, breadcrumb navigation
- [ ] Categories ordered by `category.order` ascending
- [ ] Each category shows name, point value, nominations with pick counts
- [ ] Pick counts display correctly (no N+1 queries, single aggregation)
- [ ] Revealed categories show "✓ Revealed: {nomination}" indicator
- [ ] Clicking nomination marks winner, triggers leaderboard update
- [ ] Clear button unreveals category
- [ ] Page refreshes after mutation to show updated state
- [ ] Game detail page has "Live Winner Marking" link
- [ ] All params awaited before access (Next.js 15 pattern)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- **Async params**: ALWAYS await params before accessing (Next.js 15)
- **requireValidatedSession()**: Use for all admin routes (not raw `auth()`)
- **Centralized routes**: Use `routes.admin.games.live()` for ALL navigation
- **Server/Client boundaries**: Page is Server Component, card is Client Component
- **oRPC mutations**: Use `useMutation(orpc.*.mutationOptions())`
- **Layer boundaries**: Page calls models directly (data fetching), mutations call oRPC

**Quality Gates**:
```bash
pnpm biome check --write .
pnpm test src/app/(admin)/admin/games/[gameId]/live/page.test.tsx
pnpm test src/components/admin/games/live-category-card.test.tsx
```

---

## Phase 4: Insight Rotation Framework and Integration

**Strategy**: Sequential
**Reason**: Client-side component integration with existing leaderboard

### Task 4.1: Insight Rotation Component Framework

**Files**:
- src/components/game/leaderboard/insight-rotation.tsx
- src/components/game/leaderboard/insights/live-momentum-insight.tsx
- src/components/game/leaderboard/insights/live-pick-distribution-insight.tsx
- src/components/game/leaderboard/insights/completed-accuracy-insight.tsx
- src/components/game/leaderboard/insights/completed-popularity-insight.tsx
- src/components/game/leaderboard/insights/completed-surprises-insight.tsx
- src/hooks/game/use-leaderboard-socket.ts
- src/components/game/leaderboard/leaderboard-client.tsx

**Complexity**: M (5h)

**Dependencies**: Phase 2.1 (needs GAME_COMPLETED event)

**Description**:
Build InsightRotation component that cycles between insight cards every 15 seconds. Component renders different card sets based on game status (LIVE vs COMPLETED). All individual insight components are stubbed with placeholder JSX. Update leaderboard socket hook to track gameStatus state and emit to parent. Integrate InsightRotation into LeaderboardClient.

**Implementation Steps**:

1. **Create InsightRotation orchestrator** (`src/components/game/leaderboard/insight-rotation.tsx`):
   ```typescript
   "use client";

   import { useEffect, useState } from "react";
   import type { GameStatus } from "@prisma/client";
   import { LiveMomentumInsight } from "./insights/live-momentum-insight";
   import { LivePickDistributionInsight } from "./insights/live-pick-distribution-insight";
   import { CompletedAccuracyInsight } from "./insights/completed-accuracy-insight";
   import { CompletedPopularityInsight } from "./insights/completed-popularity-insight";
   import { CompletedSurprisesInsight } from "./insights/completed-surprises-insight";

   type Props = {
     gameId: string;
     gameStatus: GameStatus;
   };

   export function InsightRotation({ gameId, gameStatus }: Props) {
     const [currentIndex, setCurrentIndex] = useState(0);

     // Define card sets by game status
     const liveInsights = [
       <LiveMomentumInsight key="momentum" gameId={gameId} />,
       <LivePickDistributionInsight key="distribution" gameId={gameId} />,
     ];

     const completedInsights = [
       <CompletedAccuracyInsight key="accuracy" gameId={gameId} />,
       <CompletedPopularityInsight key="popularity" gameId={gameId} />,
       <CompletedSurprisesInsight key="surprises" gameId={gameId} />,
     ];

     const insights = gameStatus === "COMPLETED" ? completedInsights : liveInsights;

     // Rotate every 15 seconds
     useEffect(() => {
       const interval = setInterval(() => {
         setCurrentIndex((prev) => (prev + 1) % insights.length);
       }, 15000);

       return () => clearInterval(interval);
     }, [insights.length]);

     return (
       <div className="w-full bg-white border rounded-lg p-6 shadow">
         <div className="transition-opacity duration-500">
           {insights[currentIndex]}
         </div>
       </div>
     );
   }
   ```

2. **Create stubbed insight components** (all in `src/components/game/leaderboard/insights/`):

   Each component follows this template:
   ```typescript
   "use client";

   type Props = {
     gameId: string;
   };

   export function LiveMomentumInsight({ gameId }: Props) {
     return (
       <div>
         <h3 className="text-lg font-semibold mb-4">Momentum Leaders</h3>
         <p className="text-gray-600">
           [Placeholder] Shows players with most recent correct picks
         </p>
       </div>
     );
   }
   ```

   Create 5 files with placeholders:
   - `live-momentum-insight.tsx`: "Momentum Leaders - Players with recent correct picks"
   - `live-pick-distribution-insight.tsx`: "Pick Distribution - Most popular picks per category"
   - `completed-accuracy-insight.tsx`: "Top Accuracy - Players with highest correct percentage"
   - `completed-popularity-insight.tsx`: "Popularity Contest - Most picked vs least picked winners"
   - `completed-surprises-insight.tsx`: "Biggest Upsets - Winners with fewest picks"

3. **Update leaderboard socket hook** (`src/hooks/game/use-leaderboard-socket.ts`):
   ```typescript
   export interface UseLeaderboardSocketReturn {
     players: LeaderboardPlayer[];
     connectionStatus: ConnectionStatus;
     gameStatus: GameStatus; // NEW
   }

   export function useLeaderboardSocket(
     gameId: string,
     initialData: LeaderboardPlayer[],
     initialGameStatus: GameStatus // NEW
   ): UseLeaderboardSocketReturn {
     const [players, setPlayers] = useState<LeaderboardPlayer[]>(initialData);
     const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>("connecting");
     const [gameStatus, setGameStatus] = useState<GameStatus>(initialGameStatus); // NEW

     useEffect(() => {
       // ... existing socket setup

       // NEW: Listen for game completion
       socket.on(LEADERBOARD_EVENTS.GAME_COMPLETED, (payload: GameCompletedPayload) => {
         setGameStatus("COMPLETED");
       });

       return () => {
         if (socket) {
           socket.off(LEADERBOARD_EVENTS.GAME_COMPLETED);
           socket.disconnect();
         }
       };
     }, [gameId]);

     return { connectionStatus, players, gameStatus }; // NEW: return gameStatus
   }
   ```

4. **Integrate into LeaderboardClient** (`src/components/game/leaderboard/leaderboard-client.tsx`):
   ```typescript
   export interface LeaderboardClientProps {
     gameId: string;
     initialPlayers: LeaderboardPlayer[];
     gameName: string;
     eventName: string;
     currentUserId: string;
     initialGameStatus: GameStatus; // NEW
   }

   export function LeaderboardClient({
     gameId,
     initialPlayers,
     gameName,
     eventName,
     currentUserId,
     initialGameStatus, // NEW
   }: LeaderboardClientProps) {
     const { players, connectionStatus, gameStatus } = useLeaderboardSocket(
       gameId,
       initialPlayers,
       initialGameStatus // NEW
     );

     const { reactions, sendReaction } = useReactions(gameId);

     return (
       <div className="container relative mx-auto max-w-4xl px-4 py-8">
         <GameHeader
           connectionStatus={<ConnectionStatus status={connectionStatus} />}
           eventName={eventName}
           gameName={gameName}
         />

         <ReactionDisplay reactions={reactions} currentUserId={currentUserId} />

         <LeaderboardList players={players} />

         {/* NEW: Insight rotation */}
         <InsightRotation gameId={gameId} gameStatus={gameStatus} />

         <ReactionBar
           onReactionClick={sendReaction}
           disabled={connectionStatus !== 'connected'}
         />
       </div>
     );
   }
   ```

5. **Update leaderboard page to pass gameStatus** (`src/app/game/[gameId]/leaderboard/page.tsx`):
   - Fetch game to get current status
   - Pass `initialGameStatus={game.status}` to LeaderboardClient

**Acceptance Criteria**:

- [ ] InsightRotation renders without errors
- [ ] Component switches cards every 15 seconds
- [ ] LIVE status shows 2 cards (Momentum, Pick Distribution)
- [ ] COMPLETED status shows 3 cards (Accuracy, Popularity, Surprises)
- [ ] All 5 insight components render placeholder JSX
- [ ] Cards have consistent dimensions (no layout shift)
- [ ] Fade transition between cards (CSS opacity)
- [ ] useLeaderboardSocket returns gameStatus in hook return
- [ ] Hook listens for GAME_COMPLETED event
- [ ] Hook updates gameStatus state to "COMPLETED" on event
- [ ] LeaderboardClient receives and passes initialGameStatus
- [ ] InsightRotation switches from LIVE to COMPLETED cards when event received
- [ ] No page refresh required for insight set change

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- **Client Components**: All insight components use `"use client"`
- **React hooks**: Use `useState` and `useEffect` for timer logic
- **Props typing**: Explicit TypeScript types for all props
- **WebSocket events**: Import from `@/lib/websocket/events`
- **GameStatus enum**: Import from `@prisma/client`

**Quality Gates**:
```bash
pnpm biome check --write .
pnpm test src/components/game/leaderboard/insight-rotation.test.tsx
pnpm test src/hooks/game/use-leaderboard-socket.test.ts
```

---

## Phase 5: Integration and Testing

**Strategy**: Sequential
**Reason**: Final verification phase depends on all previous tasks

### Task 5.1: End-to-End Integration and Testing

**Files**:
- All files from previous phases (verification only)

**Complexity**: M (4h)

**Dependencies**: All previous phases

**Description**:
Verify complete flow from admin marking winner → leaderboard update → game completion → insight rotation. Write integration tests covering multi-step orchestration. Ensure all constitutional patterns are followed. Test WebSocket event propagation end-to-end.

**Implementation Steps**:

1. **Write integration test** (`tests/integration/live-ceremony-flow.test.ts`):
   - Set up test game with categories and nominations
   - Simulate admin marking winners sequentially
   - Verify leaderboard updates after each winner
   - Verify game completes when last category revealed
   - Verify GAME_COMPLETED event emitted
   - Verify insight rotation switches to COMPLETED cards

2. **Manual testing checklist**:
   - [ ] Admin can access `/admin/games/{gameId}/live`
   - [ ] Categories show correct pick counts
   - [ ] Marking winner updates leaderboard in real-time
   - [ ] All connected clients see leaderboard update
   - [ ] Game auto-completes when last category revealed
   - [ ] GAME_COMPLETED event received by all clients
   - [ ] InsightRotation switches from LIVE to COMPLETED cards
   - [ ] No console errors or warnings
   - [ ] Page loads in <2 seconds with 50 categories

3. **Performance verification**:
   - [ ] Single query for pick counts (no N+1)
   - [ ] Leaderboard update broadcasts in <100ms
   - [ ] WebSocket events propagate in <50ms
   - [ ] Insight rotation timer doesn't leak memory

4. **Constitution compliance check**:
   - [ ] All params awaited before access
   - [ ] All routes use centralized `routes` object
   - [ ] All admin routes use `requireValidatedSession()`
   - [ ] All mutations use oRPC contracts
   - [ ] Services never import `@prisma/client`
   - [ ] Models only contain Prisma queries
   - [ ] ts-pattern used for GameStatus checks
   - [ ] No type assertions without validation

5. **Documentation**:
   - Update CLAUDE.md if new patterns emerged
   - Add comments to complex orchestration logic
   - Document WebSocket event payload formats

**Acceptance Criteria**:

- [ ] All integration tests pass
- [ ] Manual testing checklist 100% complete
- [ ] Performance metrics meet targets
- [ ] Constitution compliance verified
- [ ] No TypeScript errors
- [ ] No ESLint/Biome warnings
- [ ] All quality gates pass

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- **Testing**: Follow TDD principles from constitution
- **Integration tests**: Test multi-layer orchestration
- **Performance**: No N+1 queries, optimize aggregations

**Quality Gates**:
```bash
pnpm biome check --write .
pnpm test
pnpm build
```

---

## Notes

**Architecture Decisions:**

- **markWinner contracts extended** rather than creating new procedures (DRY)
- **gameId parameter** required for game completion orchestration
- **Insight rotation** uses timer in client component (not SSE)
- **Placeholder components** have consistent dimensions to prevent layout shift
- **WebSocket events** emitted from service layer, not actions

**Phase 2 Parallelization:**

Tasks 2.1 (WebSocket) and 2.2 (oRPC) are independent:
- WebSocket events only depend on existing infrastructure
- oRPC contracts extend existing admin contracts
- Both integrate in Phase 3/4 but can be developed in parallel
- 7h sequential → 3h parallel (max of 2h and 3h) = 4h saved

**Future Enhancements (Phase 2 - Visual Polish):**

- Replace insight placeholders with real data queries
- Add winner reveal animations
- Add confetti effects on game completion
- Improve card transition styling
- Mobile-first design pass
