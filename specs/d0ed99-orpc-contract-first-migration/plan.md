---
runId: d0ed99
feature: orpc-contract-first-migration
created: 2025-01-01
status: ready
---

# Feature: oRPC Contract-First Migration - Implementation Plan

> **Generated by:** Task Decomposition skill
> **From spec:** specs/d0ed99-orpc-contract-first-migration/spec.md
> **Created:** 2025-01-01

## Execution Summary

- **Total Tasks**: 5
- **Total Phases**: 3
- **Sequential Time**: 20h
- **Parallel Time**: 16h
- **Time Savings**: 4h (20% faster)

**Parallel Opportunities:**

- Phase 2: 2 tasks (4h saved)

---

## Phase 1: Contract Foundation

**Strategy**: sequential
**Reason**: Contract definitions must be complete before router implementations can reference them

### Task 1: Define Missing oRPC Contracts

**Files**:

- src/lib/api/contracts/auth.ts
- src/lib/api/contracts/game.ts
- src/lib/api/contracts/pick.ts

**Complexity**: M (4h)

**Dependencies**: None

**Description**:

Define complete oRPC contracts for auth, game, and pick routers using the `oc.input().output()` pattern. The admin router already has complete contracts defined, so this task focuses on the three remaining routers.

For each router:
1. Import existing Zod schemas from `src/schemas/` for reuse
2. Define individual procedure contracts using `oc.input(schema).output(schema)`
3. Create a router-level contract that groups all procedures
4. Follow the established admin contract pattern for consistency

**Implementation Steps**:

1. **Auth Contracts** (`src/lib/api/contracts/auth.ts`):
   - Define `signInContract` with email input, success message output
   - Define `signUpContract` with email input, success message output
   - Define `verifyEmailContract` with token input, success output
   - Export individual contracts and `authContract` router grouping

2. **Game Contracts** (`src/lib/api/contracts/game.ts`):
   - Define `joinContract` with gameId input, participant output
   - Define `resolveAccessCodeContract` with code input, {gameId, isMember} output
   - Define `getUserGamesContract` with void input, games array output
   - Export individual contracts and `gameContract` router grouping

3. **Pick Contracts** (`src/lib/api/contracts/pick.ts`):
   - Define `submitPickContract` with {gameId, categoryId, nominationId} input
   - Define output schema with {success: boolean, pick: Pick} structure
   - Export individual contract and `pickContract` router grouping

4. **Import and reuse existing schemas**:
   - Check `src/schemas/` for any auth/game/pick schemas to reuse
   - Create inline Zod schemas only if no existing schema matches
   - Ensure all contracts use proper Zod validators (cuid, email, etc.)

**Acceptance Criteria**:

- [ ] Auth contract exports 3 procedure contracts (signIn, signUp, verifyEmail)
- [ ] Game contract exports 3 procedure contracts (join, resolveAccessCode, getUserGames)
- [ ] Pick contract exports 1 procedure contract (submitPick)
- [ ] All contracts use `oc.input().output()` pattern from `@orpc/contract`
- [ ] Existing Zod schemas from `src/schemas/` reused where applicable
- [ ] Contracts match existing admin contract structure and style
- [ ] No TypeScript errors in contract files: `pnpm tsc --noEmit src/lib/api/contracts/**/*.ts`

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Zod validation (patterns.md) - All inputs validated with Zod schemas
- Type safety (patterns.md) - No `as` assertions without validation
- Layer boundaries (architecture.md) - Contracts are pure schema definitions, no business logic

**Quality Gates**:

```bash
pnpm biome check --write src/lib/api/contracts/
pnpm tsc --noEmit src/lib/api/contracts/**/*.ts
```

---

## Phase 2: Router Implementation

**Strategy**: parallel
**Reason**: Auth, game, and pick routers are independent domains with no shared dependencies; can be implemented concurrently

### Task 2: Implement Auth Router with Contract

**Files**:

- src/lib/api/routers/auth.ts
- src/lib/api/contracts/auth.ts

**Complexity**: M (3h)

**Dependencies**: task-1-define-missing-orpc-contracts

**Description**:

Refactor the auth router to use the contract-first pattern with `implement(authContract)`. Replace `{ input }: any` type annotations with properly typed procedure builders that get full type inference from the contract.

The auth router is simple (3 procedures, all calling Auth.js signIn), making it a good proof-of-concept for the contract-first pattern before applying to more complex routers.

**Implementation Steps**:

1. **Import contract and implement function**:
   - Import `authContract` from `@/lib/api/contracts/auth`
   - Import `implement` from `@orpc/server`
   - Create typed builder: `const authBuilder = implement(authContract)`

2. **Refactor signIn procedure**:
   - Change from `publicProcedure.handler(async ({ input }: any) => ...)`
   - To `authBuilder.signIn.use(publicProcedure).handler(async ({ input, ctx }) => ...)`
   - Remove type annotations - types inferred from contract
   - Verify `input.email` has proper type inference (no `any`)

3. **Refactor signUp procedure**:
   - Apply same pattern as signIn
   - Chain `authBuilder.signUp.use(publicProcedure).handler(...)`
   - Remove `any` type annotations

4. **Refactor verifyEmail procedure**:
   - Apply same pattern
   - Chain `authBuilder.verifyEmail.use(publicProcedure).handler(...)`

5. **Build final router**:
   - Export `authRouter = authBuilder.router({ signIn, signUp, verifyEmail })`
   - Or use inline: `authBuilder.router({ signIn: authBuilder.signIn.use(...), ... })`

6. **Verify type inference**:
   - Hover over `input` in each handler - should show exact contract type, not `any`
   - No TypeScript errors in router file

**Acceptance Criteria**:

- [ ] Auth router uses `implement(authContract)` to create typed builder
- [ ] All 3 procedures chain `.use(publicProcedure).handler(...)` pattern
- [ ] No `any` type annotations remain in procedure handlers
- [ ] Type inference works: `input` has exact types from contract
- [ ] Existing Auth.js signIn calls unchanged (business logic intact)
- [ ] No TypeScript errors: `pnpm tsc --noEmit src/lib/api/routers/auth.ts`

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- oRPC contract-first (patterns.md) - Use `implement(contract)` for all routers
- Layer boundaries (architecture.md) - Router calls Auth.js, no direct Prisma
- Type safety (patterns.md) - Remove all `any` annotations, rely on inference

**Quality Gates**:

```bash
pnpm biome check --write src/lib/api/routers/auth.ts
pnpm tsc --noEmit src/lib/api/routers/auth.ts
```

---

### Task 3: Implement Game and Pick Routers with Contracts

**Files**:

- src/lib/api/routers/game.ts
- src/lib/api/routers/pick.ts
- src/lib/api/contracts/game.ts
- src/lib/api/contracts/pick.ts

**Complexity**: M (4h)

**Dependencies**: task-1-define-missing-orpc-contracts

**Description**:

Refactor game and pick routers to use contract-first pattern. Game router has 3 procedures (all calling gameService), pick router has 1 procedure (calling pickService). Both routers use `authenticatedProcedure` for auth middleware.

Combined into one task because:
- Both are service-passthrough routers (no complex logic)
- Both use same auth pattern (`authenticatedProcedure`)
- Total 4 procedures - manageable in one PR
- Natural pairing: game/pick domain boundary

**Implementation Steps**:

1. **Implement Game Router**:
   - Import `gameContract` from `@/lib/api/contracts/game`
   - Create builder: `const gameBuilder = implement(gameContract)`
   - Refactor `join` procedure: `gameBuilder.join.use(authenticatedProcedure).handler(...)`
   - Refactor `resolveAccessCode` procedure: `gameBuilder.resolveAccessCode.use(authenticatedProcedure).handler(...)`
   - Refactor `getUserGames` procedure: `gameBuilder.getUserGames.use(authenticatedProcedure).handler(...)`
   - Export `gameRouter = gameBuilder.router({ join, resolveAccessCode, getUserGames })`
   - Remove all `any` type annotations

2. **Implement Pick Router**:
   - Import `pickContract` from `@/lib/api/contracts/pick`
   - Create builder: `const pickBuilder = implement(pickContract)`
   - Refactor `submitPick` procedure: `pickBuilder.submitPick.use(authenticatedProcedure).handler(...)`
   - Export `pickRouter = pickBuilder.router({ submitPick })`
   - Remove all `any` type annotations

3. **Verify type inference**:
   - Game router: `input` should have proper types (gameId, accessCode, etc.)
   - Pick router: `input` should have {gameId, categoryId, nominationId}
   - Auth context: `ctx.userId` should be typed correctly from authenticatedProcedure

4. **Verify service calls unchanged**:
   - Game router still calls `gameService.*` methods
   - Pick router still calls `pickService.submitPick`
   - No business logic changed, only type layer

**Acceptance Criteria**:

- [ ] Game router uses `implement(gameContract)` pattern
- [ ] Pick router uses `implement(pickContract)` pattern
- [ ] All 4 procedures (3 game + 1 pick) chain `.use(authenticatedProcedure).handler(...)`
- [ ] No `any` type annotations in either router
- [ ] Type inference works for all `input` and `ctx` parameters
- [ ] Service method calls unchanged (business logic intact)
- [ ] No TypeScript errors: `pnpm tsc --noEmit src/lib/api/routers/{game,pick}.ts`

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- oRPC contract-first (patterns.md) - Use `implement(contract)` for all routers
- Layer boundaries (architecture.md) - Routers call services, not models/Prisma
- Type safety (patterns.md) - No `any`, rely on contract type inference

**Quality Gates**:

```bash
pnpm biome check --write src/lib/api/routers/game.ts src/lib/api/routers/pick.ts
pnpm tsc --noEmit src/lib/api/routers/game.ts src/lib/api/routers/pick.ts
```

---

## Phase 3: Client Integration and Verification

**Strategy**: sequential
**Reason**: Admin router must be implemented before client can use updated API; client updates must happen after all routers complete

### Task 4: Implement Admin Router with Contract

**Files**:

- src/lib/api/routers/admin.ts
- src/lib/api/contracts/admin.ts

**Complexity**: L (6h)

**Dependencies**: task-2-implement-auth-router-with-contract, task-3-implement-game-and-pick-routers-with-contracts

**Description**:

Refactor the large admin router (~27 procedures across 6 domains) to use the contract-first pattern. The admin contract file already exists with complete definitions, so this task focuses on implementation.

Admin router is the most complex:
- 6 domain areas: Events, Categories, Nominations, People, Works, Games, Wikipedia Import
- ~27 total procedures
- Mix of model calls (simple CRUD) and service calls (business logic)
- All use `adminProcedure` for ADMIN role enforcement

This is saved for last because:
- It's the largest router (most procedures to refactor)
- Other routers provide proof-of-concept pattern
- Client integration depends on all routers being complete

**Implementation Steps**:

1. **Import and create builder**:
   - Verify all contracts exported from `src/lib/api/contracts/admin.ts`
   - Import individual contracts (listEventsContract, createEventContract, etc.)
   - Create builders per domain if helpful, or use single `adminBuilder`

2. **Refactor Event procedures** (5 procedures):
   - `listEvents`, `createEvent`, `updateEvent`, `deleteEvent`
   - Pattern: `adminBuilder.listEvents.use(adminProcedure).handler(...)`
   - Remove `any` type annotations
   - Keep model/service calls unchanged

3. **Refactor Category procedures** (5 procedures):
   - `createCategory`, `updateCategory`, `deleteCategory`, `markWinner`, `clearWinner`
   - Apply same builder pattern
   - Remove transform functions if contracts handle typing (evaluate if needed)

4. **Refactor Nomination procedures** (3 procedures):
   - `createNomination`, `updateNomination`, `deleteNomination`
   - Apply builder pattern

5. **Refactor Person procedures** (4 procedures):
   - `listPeople`, `createPerson`, `updatePerson`, `deletePerson`
   - Apply builder pattern

6. **Refactor Work procedures** (5 procedures):
   - `listWorks`, `createWork`, `updateWork`, `deleteWork`
   - Apply builder pattern

7. **Refactor Game procedures** (5 procedures):
   - `listGames`, `createGame`, `updateGame`, `updateGameStatus`, `deleteGame`
   - Apply builder pattern

8. **Refactor Wikipedia Import procedures** (2 procedures):
   - `previewWikipediaImport`, `importFromWikipedia`
   - Apply builder pattern
   - Verify service calls to wikipediaImportService unchanged

9. **Build final router**:
   - Group all procedures into `adminRouter`
   - May use nested structure if helpful: `adminRouter = { events: {...}, categories: {...}, ... }`
   - Or flat structure matching current pattern

10. **Verify no TypeScript errors**:
    - Check each domain section
    - Verify type inference throughout
    - Remove all `any` annotations

**Acceptance Criteria**:

- [ ] Admin router uses `implement(...)` pattern for all contracts
- [ ] All ~27 procedures use `.use(adminProcedure).handler(...)` chain
- [ ] No `any` type annotations remain in admin router
- [ ] Type inference works for all inputs (hover shows contract types)
- [ ] Model and service calls unchanged (business logic intact)
- [ ] Helper transform functions removed or kept only if necessary
- [ ] No TypeScript errors: `pnpm tsc --noEmit src/lib/api/routers/admin.ts`
- [ ] Router exports match root router expectations (structure unchanged)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- oRPC contract-first (patterns.md) - Use `implement(contract)` for all routers
- Layer boundaries (architecture.md) - Router calls services/models, no direct Prisma
- Type safety (patterns.md) - Remove all `any`, use contract type inference
- Admin authorization (patterns.md) - All procedures use `adminProcedure` with ADMIN role check

**Quality Gates**:

```bash
pnpm biome check --write src/lib/api/routers/admin.ts
pnpm tsc --noEmit src/lib/api/routers/admin.ts
```

---

### Task 5: Update Client Setup and Component Usages

**Files**:

- src/lib/api/client.ts
- src/hooks/game/use-pick-submission.ts
- src/hooks/admin/use-nomination-manager.ts
- src/hooks/admin/use-game-status.ts
- src/hooks/admin/use-event-management.ts
- src/hooks/admin/use-category-ordering.ts
- src/components/admin/games/category-card.tsx
- src/app/signup/callback/join-game-handler.tsx
- src/app/join/[code]/join-game-button.tsx
- src/app/(auth)/sign-in/page.tsx
- src/app/(admin)/admin/import/_components/import-form.tsx
- src/app/(admin)/admin/events/[id]/categories/[categoryId]/nominations/_components/delete-nomination-button.tsx

**Complexity**: M (3h)

**Dependencies**: task-4-implement-admin-router-with-contract

**Description**:

Update the HTTP client to use proper oRPC TanStack Query integration, then update all Client Component call sites to use the new `.mutationOptions()` pattern.

Two-part task:
1. **Client setup**: Replace `LinkFetchClient`/`StandardRPCLink` with `RPCLink`, add TanStack Query utils
2. **Component updates**: Change `orpc.domain.proc.useMutation()` to `useMutation(orpc.domain.proc.mutationOptions())`

This is the final task because:
- Requires all routers to be implemented with contracts
- Breaking change affects ~11 files across components and hooks
- Must be done atomically (break-and-fix migration)
- Final verification happens after this task

**Implementation Steps**:

1. **Update client.ts** (HTTP client setup):
   - Remove imports: `LinkFetchClient`, `StandardRPCLink`
   - Add import: `RPCLink` from `@orpc/client`
   - Add import: `createTanstackQueryUtils` from `@orpc/tanstack-query`
   - Replace link creation:
     ```typescript
     // OLD
     const fetchClient = new LinkFetchClient({})
     const link = new StandardRPCLink(fetchClient, { url: `${getBaseUrl()}/api/rpc` })

     // NEW
     const link = new RPCLink({
       url: `${getBaseUrl()}/api/rpc`,
       headers: async () => {
         // Import Next.js headers for SSR context
         if (typeof window === 'undefined') {
           const { headers } = await import('next/headers')
           const headersList = await headers()
           return Object.fromEntries(headersList.entries())
         }
         return {}
       }
     })
     ```
   - Create base client: `const baseClient = createORPCClient(link)`
   - Create TanStack Query utils: `export const orpc = createTanstackQueryUtils(baseClient)` (typed as `AppRouter`)
   - Verify type assertion: `as any as AppRouter` or proper typing

2. **Update hook files** (5 files in `src/hooks/`):
   - Import `useMutation` from `@tanstack/react-query`
   - Change pattern from:
     ```typescript
     const mutation = orpc.domain.proc.useMutation()
     ```
   - To:
     ```typescript
     const mutation = useMutation(orpc.domain.proc.mutationOptions())
     ```
   - Files: use-pick-submission.ts, use-nomination-manager.ts, use-game-status.ts, use-event-management.ts, use-category-ordering.ts

3. **Update component files** (6 files in `src/components/` and `src/app/`):
   - Apply same pattern change (useMutation with mutationOptions)
   - Files: category-card.tsx, join-game-handler.tsx, join-game-button.tsx, sign-in/page.tsx, import-form.tsx, delete-nomination-button.tsx

4. **Handle useQuery if needed**:
   - Search for `orpc.*.useQuery()` calls
   - Change to `useQuery(orpc.*.queryOptions())`
   - Verify no queries exist (most operations are mutations)

5. **Verify type inference throughout**:
   - Mutation inputs should be typed from contracts
   - Mutation results should be typed from contract outputs
   - No `any` or type assertions needed

6. **Test build and type check**:
   - Run `pnpm tsc --noEmit` - should have zero errors
   - Run `pnpm build` - should succeed
   - Run `pnpm dev` - should start without errors

**Acceptance Criteria**:

- [ ] Client setup uses `RPCLink` from `@orpc/client` (not LinkFetchClient/StandardRPCLink)
- [ ] Client includes Next.js headers for SSR context
- [ ] TanStack Query utils created via `createTanstackQueryUtils(baseClient)`
- [ ] All 11 client files updated to use `useMutation(orpc.*.mutationOptions())`
- [ ] No direct `.useMutation()` calls remain on orpc object
- [ ] Type inference works for mutation inputs and outputs
- [ ] Zero TypeScript errors: `pnpm tsc --noEmit`
- [ ] Build succeeds: `pnpm build`
- [ ] Dev server starts: `pnpm dev`
- [ ] All existing functionality works (manual smoke test: auth, Wikipedia import, pick submission)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- oRPC TanStack Query (patterns.md) - Use `.mutationOptions()` and `.queryOptions()`
- Client/Server boundaries (patterns.md) - Client Components use orpc HTTP client
- Type safety (patterns.md) - Full type inference from contracts to client

**Quality Gates**:

```bash
pnpm biome check --write src/lib/api/client.ts src/hooks/ src/components/ src/app/
pnpm tsc --noEmit
pnpm build
```

**Manual Testing Checklist**:

- [ ] Sign in with magic link email flow works
- [ ] Admin Wikipedia import preview works
- [ ] Admin Wikipedia import commit works
- [ ] Game join flow works (join-game-button)
- [ ] Pick submission works (use-pick-submission hook)
- [ ] Admin event/category/nomination CRUD works
- [ ] Game status updates work (use-game-status hook)

---

## Post-Implementation Verification

After all tasks complete, run full verification:

```bash
# Type check
pnpm tsc --noEmit

# Lint and format
pnpm lint

# Build
pnpm build

# Run dev server
pnpm dev
```

**Expected Results**:

- ✅ Zero TypeScript errors
- ✅ Zero Biome lint errors
- ✅ Build succeeds with no warnings
- ✅ Dev server starts without errors
- ✅ All oRPC functionality works end-to-end

**Manual Regression Testing**:

1. **Authentication Flow**:
   - Sign in with email → Magic link sent
   - Click magic link → Redirected to dashboard

2. **Admin Operations**:
   - Create event → Success
   - Import from Wikipedia → Preview + Commit work
   - Create game → Success
   - Update game status → Success
   - Mark winner → Leaderboard updates

3. **User Operations**:
   - Join game with code → Success
   - Submit picks → Success
   - View leaderboard → Updates in real-time

**Rollback Plan**:

If critical issues arise after migration:
1. Git revert the merged PR
2. Redeploy previous version
3. Fix issues in new branch
4. Re-test before merge

---

## Constitution Reference

> **All tasks MUST follow**: @docs/constitutions/current/

**Key files**:
- `architecture.md` - Layer boundaries (Models → Services → oRPC → UI)
- `patterns.md` - Mandatory patterns (oRPC contract-first, type safety, authentication)
- `tech-stack.md` - Approved dependencies (verify oRPC packages)
- `testing.md` - TDD requirements (if tests needed)

**Critical patterns for this feature**:
- oRPC contract-first: Define contracts with `oc.input().output()`, implement with `implement(contract)`
- Type safety: Remove all `any` annotations, rely on contract type inference
- TanStack Query: Use `.mutationOptions()` and `.queryOptions()` pattern
- Layer boundaries: Routers call services/models, never Prisma directly
