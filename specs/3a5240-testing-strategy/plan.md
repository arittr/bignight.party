---
runId: 3a5240
feature: testing-strategy
created: 2025-01-20
status: ready
---

# Feature: Comprehensive Testing Strategy with Vitest - Implementation Plan

> **Generated by:** Task Decomposition skill
> **From spec:** specs/3a5240-testing-strategy/spec.md
> **Created:** 2025-01-20

## Execution Summary

- **Total Tasks**: 6
- **Total Phases**: 3
- **Sequential Time**: 27h
- **Parallel Time**: 20h
- **Time Savings**: 7h (26% faster)

**Parallel Opportunities:**
- Phase 2: 3 tasks (7h saved with parallelization)

---

## Phase 1: Test Foundation & Database Setup

**Strategy**: Sequential
**Reason**: Infrastructure must be in place before test implementation

### Task 1.1: Test Infrastructure Foundation

**Files**:
- `package.json` - Add Vitest dependencies and test scripts
- `vitest.config.ts` - Vitest configuration with React plugin, path aliases
- `docker-compose.yml` - Add bignight_test database service on port 5433
- `.env.test` - Test environment variables
- `.gitignore` - Add coverage/ directory
- `tests/setup/database.ts` - Test database lifecycle management
- `tests/utils/prisma.ts` - Shared test Prisma client and utilities

**Complexity**: M (4h)

**Dependencies**: None

**Description**:
Set up the complete testing infrastructure foundation: install Vitest and testing libraries, configure test runner with TypeScript support and path aliases, add test database container to Docker, create environment configuration, and implement database lifecycle management (migrations in beforeAll, truncation in afterEach, disconnect in afterAll).

**Implementation Steps**:
1. Install dependencies: `vitest`, `@vitest/ui`, `@vitejs/plugin-react`, `@testing-library/react`, `@testing-library/user-event`, `happy-dom`
2. Add NPM scripts to package.json: `test`, `test:run`, `test:coverage`, `test:models`, `test:services`, `test:ui`
3. Create vitest.config.ts with:
   - TypeScript support
   - Path aliases matching tsconfig.json (@/lib/*, @/components/*, etc.)
   - React plugin for component testing
   - Global setup pointing to tests/setup/database.ts
   - happy-dom environment for component tests
4. Update docker-compose.yml to add bignight_test PostgreSQL service on port 5433
5. Create .env.test with DATABASE_URL_TEST pointing to test database
6. Add coverage/ to .gitignore
7. Create tests/setup/database.ts with:
   - beforeAll: Run Prisma migrations against test database
   - afterEach: Truncate all tables (fast cleanup between tests)
   - afterAll: Disconnect Prisma client
8. Create tests/utils/prisma.ts with shared test Prisma client and truncate helper function

**Acceptance Criteria**:
- [ ] `pnpm install` succeeds with all testing dependencies
- [ ] `pnpm stack:up` starts both dev and test PostgreSQL databases
- [ ] Test database accessible at localhost:5433
- [ ] Vitest config loads without errors
- [ ] Database setup runs migrations successfully in test suite
- [ ] `pnpm test:run` executes (even with no tests yet)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Testing infrastructure follows @docs/constitutions/current/testing.md
- Database setup uses existing Prisma schema from @docs/constitutions/current/schema-rules.md
- All dependencies approved per @docs/constitutions/current/tech-stack.md

**Quality Gates**:
```bash
pnpm lint
pnpm test:run
docker ps | grep bignight_test
```

---

## Phase 2: Test Data & Utilities (Parallel)

**Strategy**: Parallel
**Reason**: Factories, fixtures, and mocks are independent - can be implemented simultaneously

### Task 2.1: Test Factories

**Files**:
- `tests/factories/game.ts` - Game factory with sensible defaults
- `tests/factories/pick.ts` - Pick factory
- `tests/factories/category.ts` - Category factory
- `tests/factories/nomination.ts` - Nomination factory
- `tests/factories/event.ts` - Event factory
- `tests/factories/user.ts` - User factory
- `tests/factories/index.ts` - Barrel export for all factories

**Complexity**: M (3h)

**Dependencies**: Task 1.1 (needs Prisma types and test utils)

**Description**:
Create factory functions for all core models to enable easy test data creation. Each factory provides sensible defaults and accepts partial overrides, following the builder pattern. Factories return typed objects matching Prisma models and can be used in both model tests (with real DB) and service tests (as mock return values).

**Implementation Steps**:
1. Create tests/factories/ directory
2. For each model (Game, Pick, Category, Nomination, Event, User):
   - Import Prisma type
   - Create buildX function accepting optional Partial<X>
   - Provide sensible defaults (valid IDs, realistic data, proper relationships)
   - Return merged defaults + overrides
3. Example pattern:
   ```typescript
   export function buildGame(overrides: Partial<Game> = {}): Game {
     return {
       id: 'game-test-1',
       name: 'Test Game',
       eventId: 'event-test-1',
       accessCode: 'TEST123',
       status: GameStatus.OPEN,
       createdAt: new Date(),
       updatedAt: new Date(),
       ...overrides,
     }
   }
   ```
4. Create index.ts barrel export for convenient imports
5. Document factory usage patterns in factories/README.md

**Acceptance Criteria**:
- [ ] Factory for each core model (Game, Pick, Category, Nomination, Event, User)
- [ ] Each factory accepts Partial<Model> for overrides
- [ ] Sensible defaults for all required fields
- [ ] TypeScript types properly inferred
- [ ] Can import all factories from tests/factories

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Factories return types matching Prisma models per @docs/constitutions/current/schema-rules.md
- Use enums from Prisma (GameStatus, Role) per @docs/constitutions/current/patterns.md
- Follow TypeScript strict mode per @docs/constitutions/current/tech-stack.md

**Quality Gates**:
```bash
pnpm lint
pnpm check-types
```

---

### Task 2.2: Test Fixtures

**Files**:
- `tests/fixtures/events.ts` - Pre-defined Event test data
- `tests/fixtures/games.ts` - Pre-defined Game test data
- `tests/fixtures/categories.ts` - Pre-defined Category test data
- `tests/fixtures/nominations.ts` - Pre-defined Nomination test data
- `tests/fixtures/index.ts` - Barrel export for all fixtures

**Complexity**: M (2h)

**Dependencies**: Task 1.1 (needs Prisma types)

**Description**:
Create fixture data representing realistic, commonly-used test scenarios. Fixtures are complete, pre-configured objects (unlike factories which build custom data). Examples: OSCARS_2025_EVENT, OPEN_GAME_FIXTURE, BEST_PICTURE_CATEGORY. Fixtures reduce test boilerplate for common scenarios and ensure consistency across test suites.

**Implementation Steps**:
1. Create tests/fixtures/ directory
2. Create events.ts with realistic event fixtures:
   - OSCARS_2025_EVENT (status: OPEN, picksLockAt in future)
   - OSCARS_2024_EVENT (status: COMPLETED)
   - GRAMMYS_2025_EVENT (status: SETUP)
3. Create games.ts with game fixtures covering all statuses:
   - OPEN_GAME_FIXTURE (status: OPEN, valid access code)
   - LIVE_GAME_FIXTURE (status: LIVE, picks locked)
   - COMPLETED_GAME_FIXTURE (status: COMPLETED)
4. Create categories.ts with category fixtures:
   - BEST_PICTURE_CATEGORY (points: 10, multiple nominations)
   - BEST_ACTOR_CATEGORY (points: 5)
5. Create nominations.ts with nomination fixtures linked to categories
6. Create index.ts barrel export
7. Document fixture usage in fixtures/README.md

**Acceptance Criteria**:
- [ ] At least 3 event fixtures covering different statuses
- [ ] At least 3 game fixtures (SETUP, OPEN, LIVE, COMPLETED)
- [ ] Categories with realistic point values
- [ ] Nominations properly linked to categories
- [ ] All fixtures use realistic data (not "test1", "test2")

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Fixture data follows schema rules per @docs/constitutions/current/schema-rules.md
- Game status transitions follow state machine per @docs/constitutions/current/patterns.md
- Realistic data improves test readability per @docs/constitutions/current/testing.md

**Quality Gates**:
```bash
pnpm lint
pnpm check-types
```

---

### Task 2.3: Test Mocks & Utilities

**Files**:
- `tests/utils/mocks.ts` - Common mock implementations for models and actions
- `tests/utils/test-helpers.ts` - Shared test utilities (assertions, matchers)
- `tests/utils/index.ts` - Barrel export

**Complexity**: M (2h)

**Dependencies**: Task 1.1 (needs test infrastructure)

**Description**:
Create reusable mock implementations and test utilities to reduce boilerplate in service and component tests. Mocks include pre-configured vi.mock() setups for common model functions and server actions. Utilities include custom matchers, assertion helpers, and setup functions for repetitive test patterns.

**Implementation Steps**:
1. Create tests/utils/mocks.ts with:
   - mockGameModel() - Returns mocked game model functions
   - mockPickModel() - Returns mocked pick model functions
   - mockGameParticipantModel() - Returns mocked participant functions
   - mockServerAction() - Helper for mocking next-safe-action actions
   - resetAllMocks() - Convenience function to clear all mocks
2. Create tests/utils/test-helpers.ts with:
   - expectToThrow() - Cleaner async error assertions
   - waitForDbWrite() - Helper for timing-dependent tests
   - Custom matchers (e.g., toMatchGameStatus, toBeValidPick)
3. Create index.ts barrel export
4. Document mock patterns in utils/README.md with examples

**Acceptance Criteria**:
- [ ] Mock functions for all critical models (Game, Pick, GameParticipant)
- [ ] Server action mock helper
- [ ] At least 3 custom test utilities/matchers
- [ ] All mocks properly typed with TypeScript
- [ ] Documentation with usage examples

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Mocks respect layer boundaries per @docs/constitutions/current/architecture.md
- Don't mock what you're testing per @docs/constitutions/current/testing.md
- Use vi.mock() from Vitest per @docs/constitutions/current/tech-stack.md

**Quality Gates**:
```bash
pnpm lint
pnpm check-types
```

---

## Phase 3: Test Implementation (Sequential)

**Strategy**: Sequential
**Reason**: Tests should be implemented after infrastructure and utilities are complete

### Task 3.1: Model Layer Tests

**Files**:
- `src/lib/models/__tests__/game-participant.test.ts` - Migrate existing stub test
- `src/lib/models/__tests__/game.test.ts` - New test for game model
- `src/lib/models/__tests__/pick.test.ts` - New test for pick model

**Complexity**: L (5h)

**Dependencies**: Task 2.1, Task 2.2 (needs factories and fixtures)

**Description**:
Implement model layer tests using real test database (no mocking). Migrate existing game-participant stub test to working implementation. Add new tests for game and pick models. Tests verify Prisma queries, database constraints (unique constraints, foreign keys), referential integrity (cascading deletes), and query correctness (findByAccessCode returns null for invalid codes, etc.).

**Implementation Steps**:
1. Migrate game-participant.test.ts:
   - Uncomment existing test code
   - Update to use test database from setup
   - Replace mock data with factories
   - Add tests for unique constraints, foreign keys
   - Verify exists() returns boolean correctly
2. Create game.test.ts:
   - Test findById returns game or null
   - Test findByAccessCode with valid/invalid codes
   - Test unique constraint on accessCode
   - Test cascading delete (deleting game deletes picks)
   - Test all GameStatus enum values are valid
3. Create pick.test.ts:
   - Test create enforces unique constraint [gameId, userId, categoryId]
   - Test upsert creates new pick or updates existing
   - Test foreign key constraints (invalid gameId throws)
   - Test findByGameAndUser returns user's picks
   - Test getPicksCountByGameAndUser returns correct count
4. Use factories for test data creation
5. Use database truncation (from setup) for test isolation

**Acceptance Criteria**:
- [ ] game-participant.test.ts migrated and all tests pass
- [ ] game.test.ts covers findById, findByAccessCode, constraints
- [ ] pick.test.ts covers unique constraints, upsert, foreign keys
- [ ] All tests use real test database (no mocks)
- [ ] Tests are isolated (truncation between tests works)
- [ ] All tests pass with `pnpm test:models`

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Model tests use real DB per @docs/constitutions/current/testing.md
- No business logic in tests (only data access verification)
- Test organization follows __tests__/ pattern per @docs/constitutions/current/testing.md
- TDD workflow: Write test (RED) → Minimal code (GREEN) → Refactor

**Quality Gates**:
```bash
pnpm lint
pnpm test:models
pnpm test:run
```

---

### Task 3.2: Service Layer Tests

**Files**:
- `src/lib/services/__tests__/game-service.test.ts` - Migrate existing stub test
- `src/lib/services/__tests__/pick-service.test.ts` - Migrate existing stub test
- `src/lib/services/__tests__/admin-service.test.ts` - New test for admin service

**Complexity**: L (6h)

**Dependencies**: Task 2.1, Task 2.3 (needs factories and mocks)

**Description**:
Implement service layer tests with mocked model imports. Migrate existing game-service and pick-service stub tests. Add new admin-service tests. Focus on business logic: state machines (ts-pattern exhaustive matching), validation rules, error handling, orchestration between models. Critical flows: pick submission state machine (game status transitions), winner marking, leaderboard calculation, game participation, access code resolution.

**Implementation Steps**:
1. Migrate game-service.test.ts:
   - Uncomment and update with proper vi.mock() setup
   - Use mockGameModel and mockGameParticipantModel from test utils
   - Test joinGame creates participant when game exists
   - Test joinGame throws when game doesn't exist
   - Test resolveAccessCode returns { gameId, isMember } correctly
   - Test getUserGames calculates completion count (picks vs categories)
2. Migrate pick-service.test.ts:
   - Uncomment and update with proper mocking
   - Test submitPick validates game status using ts-pattern:
     - SETUP → rejects
     - OPEN → accepts
     - LIVE → rejects
     - COMPLETED → rejects
   - Test submitPick validates user is game participant
   - Test submitPick validates nomination belongs to category
   - Test submitPick creates/updates pick when valid
3. Create admin-service.test.ts:
   - Test markWinner validates winner belongs to category
   - Test markWinner updates winnerId and isRevealed
   - Test calculateLeaderboard aggregates picks by user
   - Test calculateLeaderboard sums points for correct picks (nominationId === winnerId)
   - Test calculateLeaderboard only counts revealed categories
4. All tests mock model layer (no database queries)
5. Use factories for creating test data as mock return values

**Acceptance Criteria**:
- [ ] game-service.test.ts migrated with proper mocking
- [ ] pick-service.test.ts migrated and tests ts-pattern exhaustive state machine
- [ ] admin-service.test.ts tests winner marking and leaderboard calculation
- [ ] All model imports are mocked (no real DB queries)
- [ ] State machine tests use ts-pattern with .exhaustive()
- [ ] All tests pass with `pnpm test:services`
- [ ] Service tests run in <5 seconds (NFR1)

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Mock all model imports per @docs/constitutions/current/testing.md
- Verify ts-pattern exhaustive matching per @docs/constitutions/current/patterns.md
- Test business logic only (no data access) per @docs/constitutions/current/architecture.md
- Use vi.mock() from Vitest per @docs/constitutions/current/tech-stack.md

**Quality Gates**:
```bash
pnpm lint
pnpm test:services
pnpm test:run
```

---

### Task 3.3: Component Tests (Critical UI Only)

**Files**:
- `src/components/__tests__/PickForm.test.tsx` - Test pick submission form
- `src/app/(admin)/admin/_components/__tests__/ConfirmDeleteButton.test.tsx` - Test delete confirmation

**Complexity**: M (5h)

**Dependencies**: Task 2.3 (needs mock utilities)

**Description**:
Implement component tests for two critical UI components using @testing-library/react with mocked server actions. PickForm tests: renders category and nominees, submits pick with correct data. ConfirmDeleteButton tests: shows confirmation dialog, only calls delete action after confirmation. Focus on user interactions and action invocations (not implementation details).

**Implementation Steps**:
1. Create PickForm.test.tsx:
   - Test renders category name
   - Test renders all nominees
   - Test selecting a nominee updates UI state
   - Test clicking submit calls server action with correct { categoryId, nominationId }
   - Test shows success message after submission
   - Test shows error message on submission failure
   - Mock submitPickAction using test utilities
2. Create ConfirmDeleteButton.test.tsx:
   - Test renders delete button
   - Test clicking button shows confirmation dialog
   - Test canceling confirmation does NOT call delete action
   - Test confirming calls delete action
   - Test shows loading state during deletion
   - Mock delete action using test utilities
3. Use @testing-library/react render, screen, fireEvent
4. Use @testing-library/user-event for realistic interactions
5. Mock server actions (not implementation)
6. Use happy-dom environment from vitest config

**Acceptance Criteria**:
- [ ] PickForm.test.tsx covers rendering, selection, submission
- [ ] ConfirmDeleteButton.test.tsx covers confirmation flow
- [ ] All server actions are mocked (no real API calls)
- [ ] Tests verify user interactions (not implementation details)
- [ ] Tests use @testing-library/react best practices (query by role, accessible names)
- [ ] All tests pass with `pnpm test:ui`

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- Mock server actions per @docs/constitutions/current/testing.md
- Test user behavior, not implementation per @docs/constitutions/current/testing.md
- Use @testing-library/react from approved tech stack per @docs/constitutions/current/tech-stack.md
- Follow component testing patterns per @docs/constitutions/current/patterns.md

**Quality Gates**:
```bash
pnpm lint
pnpm test:ui
pnpm test:run
pnpm test:coverage
```

---

## Execution Time Analysis

### Total Sequential Time: 27 hours
- Phase 1: 4h
- Phase 2: 3h + 2h + 2h = 7h (if sequential)
- Phase 3: 5h + 6h + 5h = 16h

### With Parallelization: 20 hours
- Phase 1: 4h (sequential)
- Phase 2: max(3h, 2h, 2h) = 3h (parallel)
- Phase 3: 5h + 6h + 5h = 16h (sequential - requires Phase 2 completion)

### Time Savings: 7 hours (26% faster)

**Parallelization Strategy:**
- Phase 2 tasks (Factories, Fixtures, Mocks) are completely independent
- Can be implemented simultaneously by different developers or agents
- Saves 4 hours (7h sequential → 3h parallel)

---

## Quality Gates Summary

All tasks must pass:
```bash
# Linting and type checking
pnpm lint

# Layer-specific tests
pnpm test:models
pnpm test:services
pnpm test:ui

# All tests
pnpm test:run

# Coverage report
pnpm test:coverage
```

**Coverage Targets** (from NFR8):
- Statements: 80% minimum
- Branches: 75% minimum
- Critical business logic paths: >80%

---

## Constitution Compliance

> **All tasks MUST follow**: @docs/constitutions/current/

Every task references the constitution for:
- **Architecture**: Layer boundaries (Models → Services → Components)
- **Patterns**: ts-pattern exhaustive matching, mocking strategies, TDD workflow
- **Testing Standards**: Test organization, quality rules, what to test/skip
- **Tech Stack**: Vitest, @testing-library/react, happy-dom

## Next Steps

### Review Plan
```bash
cat specs/3a5240-testing-strategy/plan.md
```

### Execute Plan
```bash
/execute @specs/3a5240-testing-strategy/plan.md
```

### Or Execute Individual Tasks
```bash
# Start with infrastructure
# Implement Task 1.1: Test Infrastructure Foundation

# Then parallelize Phase 2
# Implement Tasks 2.1, 2.2, 2.3 simultaneously

# Finally implement tests sequentially
# Implement Task 3.1, then 3.2, then 3.3
```
