---
runId: 33d0e1
feature: real-time-reactions
created: 2025-11-03
status: ready
---

# Feature: Real-Time Reactions - Implementation Plan

> **Generated by:** Task Decomposition skill
> **From spec:** specs/33d0e1-real-time-reactions/spec.md
> **Created:** 2025-11-03

## Execution Summary

- **Total Tasks**: 4
- **Total Phases**: 3
- **Sequential Time**: 16h
- **Parallel Time**: 14h
- **Time Savings**: 2h (12.5%)

**Parallel Opportunities:**

- Phase 2: 2 tasks (2h saved)

---

## Phase 1: WebSocket Foundation

**Strategy**: sequential
**Reason**: Server-side types and handler must be in place before client-side work

### Task 1: WebSocket Foundation for Reactions

**Files**:

- src/types/leaderboard.ts
- src/lib/websocket/server.ts
- src/lib/models/user.ts (read only)
- src/lib/models/game-participant.ts (read only)

**Complexity**: M (4h)

**Dependencies**: None

**Description**:

Add type definitions and server-side WebSocket handler for real-time reactions. This establishes the foundation for both client and server to communicate emoji reactions with full type safety and validation.

**Implementation Steps**:

1. **Add reaction types to `src/types/leaderboard.ts`**:

   - Add `ReactionPayload` interface (server ‚Üí client broadcast)
   - Add `Reaction` interface (client-side state with unique ID)
   - Add `ReactionSendPayload` interface (client ‚Üí server request)
   - Follow existing pattern of `LeaderboardUpdatePayload` structure

2. **Add reaction handler to `src/lib/websocket/server.ts`**:

   - Inside `setupConnectionHandler()`, after the "join" handler (line 167)
   - Listen for `LEADERBOARD_EVENTS.REACTION_SEND` event
   - Define `ALLOWED_EMOJIS` constant: `['üî•', 'üòç', 'üò±', 'üíÄ']`
   - Validate payload: check emoji is in `ALLOWED_EMOJIS`, check `gameId` exists
   - Validate user is participant: `await gameParticipantModel.exists(userId, gameId)`
   - Fetch user name: `await userModel.findById(userId)`
   - Broadcast to game room: `server.to(gameId).emit(LEADERBOARD_EVENTS.REACTION_BROADCAST, { emoji, userId, userName, gameId, timestamp })`
   - Pattern: Follow existing "join" handler validation style (lines 128-166)

3. **Verify WebSocket events exist**:
   - Confirm `LEADERBOARD_EVENTS.REACTION_SEND` and `LEADERBOARD_EVENTS.REACTION_BROADCAST` already defined in `src/lib/websocket/events.ts` (spec says they exist, verify only)

**Acceptance Criteria**:

- [ ] `ReactionPayload`, `Reaction`, and `ReactionSendPayload` types exported from `src/types/leaderboard.ts`
- [ ] Server handler validates emoji against `ALLOWED_EMOJIS` array
- [ ] Server handler validates user is game participant before broadcasting
- [ ] Server handler fetches user name and includes in broadcast payload
- [ ] Server broadcasts to game room using `server.to(gameId).emit()`
- [ ] TypeScript strict mode passes with no type errors
- [ ] Biome lint/format passes

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- **Architecture**: WebSocket handlers in `src/lib/websocket/server.ts` (architecture.md)
- **Type Safety**: All payloads typed in `src/types/` (patterns.md)
- **Validation**: Server-side validation of emoji and participant status (patterns.md)

**Quality Gates**:

```bash
pnpm biome check --write .
pnpm tsc --noEmit
```

---

## Phase 2: Client Foundation

**Strategy**: parallel
**Reason**: Hook and components are independent units that don't share files

### Task 2: Reaction Hook with Auto-Cleanup

**Files**:

- src/hooks/game/use-reactions.ts
- src/types/leaderboard.ts (read only)
- src/lib/websocket/events.ts (read only)

**Complexity**: M (4h)

**Dependencies**: task-1-websocket-foundation

**Description**:

Create custom React hook managing WebSocket connection for reactions. The hook maintains ephemeral state (reactions array) with automatic cleanup timers to remove reactions after 3 seconds, following the pattern established by `useLeaderboardSocket`.

**Implementation Steps**:

1. **Create `src/hooks/game/use-reactions.ts`**:

   - Follow structure of `src/hooks/game/use-leaderboard-socket.ts` (connection pattern, cleanup)
   - Import types: `Reaction`, `ReactionPayload` from `@/types/leaderboard`
   - Import `LEADERBOARD_EVENTS` from `@/lib/websocket/events`
   - Import Socket.io client: `import { io, type Socket } from "socket.io-client"`

2. **State management**:

   - State: `reactions: Reaction[]` (array of active reactions)
   - Generate unique IDs for each reaction: `crypto.randomUUID()` or `Date.now() + Math.random()`
   - Track cleanup timers: `Map<string, NodeJS.Timeout>` to store timer for each reaction ID

3. **WebSocket connection**:

   - Reuse existing Socket.io connection pattern from `useLeaderboardSocket`
   - Connect to same server (`io()` with no custom config)
   - Auto-join game room via `LEADERBOARD_EVENTS.JOIN` (reuse existing join flow)
   - Listen for `LEADERBOARD_EVENTS.REACTION_BROADCAST` event

4. **Reaction broadcast listener**:

   - On `REACTION_BROADCAST` event, receive `ReactionPayload`
   - Create `Reaction` object with unique `id` field
   - Add to `reactions` state array
   - Set 3-second cleanup timer: `setTimeout(() => removeReaction(id), 3000)`
   - Store timer in Map for manual cleanup on unmount

5. **Send reaction function**:

   - Export `sendReaction(emoji: string)` function
   - Emit `LEADERBOARD_EVENTS.REACTION_SEND` with `{ emoji, gameId }`
   - No optimistic UI update (wait for server broadcast)

6. **Cleanup**:
   - On unmount: Clear all timers, disconnect socket (follow `useLeaderboardSocket` cleanup)
   - On reaction removal: Delete timer from Map, remove from state array

**Acceptance Criteria**:

- [ ] Hook exports `{ reactions, sendReaction }` interface
- [ ] `sendReaction(emoji)` emits `reaction:send` event with `{ emoji, gameId }`
- [ ] Reactions auto-remove after 3 seconds with cleanup timer
- [ ] Each reaction has unique `id` for React keys
- [ ] All timers cleared on unmount (no memory leaks)
- [ ] WebSocket connection reused (same connection as leaderboard hook)
- [ ] TypeScript strict mode passes with no type errors
- [ ] Biome lint/format passes

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- **Custom Hooks**: Follow `useLeaderboardSocket` pattern (patterns.md - Modular Component Architecture)
- **WebSocket Connection**: Reuse existing Socket.io connection (no second connection)
- **Memory Management**: Clean up timers on unmount (patterns.md - useEffect cleanup)
- **Type Safety**: All event payloads typed (architecture.md)

**Quality Gates**:

```bash
pnpm biome check --write .
pnpm tsc --noEmit
```

### Task 3: Reaction UI Components

**Files**:

- src/components/game/leaderboard/reaction-bar.tsx
- src/components/game/leaderboard/reaction-button.tsx
- src/components/game/leaderboard/reaction-display.tsx

**Complexity**: M (4h)

**Dependencies**: task-1-websocket-foundation

**Description**:

Create three Client Components for reaction UI: `ReactionBar` (emoji button container), `ReactionButton` (individual emoji button with shadcn/ui), and `ReactionDisplay` (floating overlay with Framer Motion animations). All components use Modular Component Architecture pattern.

**Implementation Steps**:

1. **Create `src/components/game/leaderboard/reaction-button.tsx`**:

   - Client Component (`"use client"`)
   - Props: `{ emoji: string, onClick: () => void, disabled?: boolean, ariaLabel: string }`
   - Use shadcn/ui `Button` component (import from `@/components/ui/button`)
   - Variant: `"ghost"` or `"outline"` for clean look
   - Size: Large (text-4xl or text-5xl for emoji)
   - Hover animation: `hover:scale-110 transition-transform`
   - Accessibility: `aria-label={ariaLabel}` (e.g., "Fire reaction button")
   - Disabled state: `disabled={disabled}` prop passed to Button

2. **Create `src/components/game/leaderboard/reaction-bar.tsx`**:

   - Client Component (`"use client"`)
   - Props: `{ onReactionClick: (emoji: string) => void, disabled?: boolean }`
   - Render 4 `ReactionButton` components for: üî•, üòç, üò±, üíÄ
   - Layout: Horizontal flexbox, centered, gap-2 or gap-4
   - Positioning: Fixed at bottom of container (relative to LeaderboardClient parent)
   - Responsive: Stack on mobile if needed (flex-wrap)
   - Pass `disabled` prop to all buttons
   - ARIA labels: "Fire reaction button", "Love it reaction button", "Shocked reaction button", "Dead reaction button"

3. **Create `src/components/game/leaderboard/reaction-display.tsx`**:

   - Client Component (`"use client"`)
   - Props: `{ reactions: Reaction[], currentUserId?: string }`
   - Import Framer Motion: `import { AnimatePresence, motion } from "framer-motion"`
   - Use `<AnimatePresence>` wrapper for exit animations
   - Map over `reactions` array, render each as `<motion.div>`
   - Key: `reaction.id` (unique per reaction)
   - Display: `{reaction.emoji} {reaction.userName}`
   - Positioning: Absolute/fixed overlay above leaderboard content
   - Animation variants:
     - Enter: `initial={{ opacity: 0, y: 20 }}`, `animate={{ opacity: 1, y: 0 }}`
     - Exit: `exit={{ opacity: 0 }}`
     - Transition: `transition={{ duration: 0.3 }}`
   - Layout: Stacked (flex-col) or randomized positioning to avoid overlap
   - Optional: Highlight current user's reactions with different styling (`reaction.userId === currentUserId`)

4. **Styling**:
   - Use Tailwind CSS for all styling
   - ReactionBar: Bottom-fixed, centered, padding for touch targets
   - ReactionButton: Large touch-friendly size (min 48x48px for accessibility)
   - ReactionDisplay: Floating overlay with z-index above content, pointer-events-none to avoid blocking clicks

**Acceptance Criteria**:

- [ ] `ReactionButton` uses shadcn/ui Button primitive with aria-label
- [ ] `ReactionBar` renders 4 emoji buttons (üî•, üòç, üò±, üíÄ)
- [ ] `ReactionBar` buttons disabled when `disabled={true}`
- [ ] `ReactionDisplay` uses Framer Motion AnimatePresence for enter/exit animations
- [ ] Reactions fade in with slide animation, fade out after 3 seconds
- [ ] Each reaction shows emoji + userName
- [ ] Current user's reactions visually distinct (optional bonus)
- [ ] All components are Client Components with `"use client"` directive
- [ ] TypeScript strict mode passes with no type errors
- [ ] Biome lint/format passes

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- **Modular Component Architecture**: Custom Hooks ‚Üí Feature Components ‚Üí shadcn/ui Primitives (patterns.md)
- **Client Components**: All interactive components require `"use client"` (patterns.md)
- **shadcn/ui**: Use Button primitive for accessibility (tech-stack.md)
- **Framer Motion**: Use AnimatePresence for exit animations (tech-stack.md)
- **Accessibility**: ARIA labels, keyboard navigation, touch-friendly sizes (patterns.md)

**Quality Gates**:

```bash
pnpm biome check --write .
pnpm tsc --noEmit
```

---

## Phase 3: Integration

**Strategy**: sequential
**Reason**: Requires all previous work to be complete

### Task 4: Integrate Reactions into Leaderboard

**Files**:

- src/components/game/leaderboard/leaderboard-client.tsx
- src/hooks/game/use-reactions.ts (read only)
- src/components/game/leaderboard/reaction-bar.tsx (read only)
- src/components/game/leaderboard/reaction-display.tsx (read only)

**Complexity**: M (4h)

**Dependencies**: task-2-reaction-hook, task-3-reaction-ui

**Description**:

Integrate reaction hook and components into `LeaderboardClient` orchestrator. Add `useReactions()` hook call, render `ReactionDisplay` as floating overlay, and render `ReactionBar` at bottom with connection-aware disabled state.

**Implementation Steps**:

1. **Add reaction hook to `LeaderboardClient`**:

   - Import `useReactions` from `@/hooks/game/use-reactions`
   - Call hook: `const { reactions, sendReaction } = useReactions(gameId)`
   - Placed after existing `useLeaderboardSocket()` call (line 50)

2. **Render `ReactionDisplay` component**:

   - Import `ReactionDisplay` from `./reaction-display`
   - Add before `<LeaderboardList>` (line 62)
   - Props: `<ReactionDisplay reactions={reactions} currentUserId={session.user.id} />`
   - Note: Need to get `session.user.id` - may require passing from parent or using auth context
   - If session not available in client component, pass `currentUserId` as prop from parent Server Component

3. **Render `ReactionBar` component**:

   - Import `ReactionBar` from `./reaction-bar`
   - Add after `<LeaderboardList>` (bottom of container)
   - Props: `<ReactionBar onReactionClick={sendReaction} disabled={connectionStatus !== 'connected'} />`
   - Disabled when WebSocket disconnected (reuse `connectionStatus` from `useLeaderboardSocket`)

4. **Pass currentUserId prop if needed**:

   - Check if `LeaderboardClient` receives `currentUserId` prop from parent
   - If not, update `LeaderboardClientProps` interface to include `currentUserId?: string`
   - Update parent Server Component to pass `currentUserId={session.user.id}`

5. **Layout adjustments**:
   - Ensure container has relative positioning for ReactionBar fixed positioning
   - Adjust z-index if needed to ensure ReactionDisplay floats above LeaderboardList
   - Test responsive layout (reactions should not overflow on mobile)

**Acceptance Criteria**:

- [ ] `useReactions()` hook called in `LeaderboardClient`
- [ ] `ReactionDisplay` renders above player list with floating overlay
- [ ] `ReactionBar` renders at bottom of container
- [ ] ReactionBar disabled when `connectionStatus !== 'connected'`
- [ ] Current user's reactions highlighted (if `currentUserId` passed correctly)
- [ ] Click reaction button ‚Üí reaction appears on all connected clients
- [ ] Reactions auto-remove after 3 seconds
- [ ] Multiple reactions display simultaneously without overlapping
- [ ] Layout responsive on mobile (buttons stack if needed)
- [ ] TypeScript strict mode passes with no type errors
- [ ] Biome lint/format passes
- [ ] Manual testing: Open 2 browser tabs ‚Üí click reaction in tab 1 ‚Üí appears in tab 2

**Mandatory Patterns**:

> **Constitution**: All code must follow @docs/constitutions/current/

- **Component Orchestration**: LeaderboardClient coordinates all child components (patterns.md)
- **Server/Client Boundaries**: Pass server-side data (currentUserId) as props to client components (patterns.md)
- **Connection-Aware UI**: Disable interactions when WebSocket disconnected (patterns.md)

**Quality Gates**:

```bash
pnpm biome check --write .
pnpm tsc --noEmit
pnpm dev
# Manual testing: Test in 2 browser tabs
```

---

## Notes

### No Database Persistence

This feature intentionally does NOT persist reactions to the database, per `docs/constitutions/current/schema-rules.md` "No Reaction Table" section. Reactions are ephemeral, in-memory only, and disappear on page refresh.

### WebSocket Event Reuse

Events `REACTION_SEND` and `REACTION_BROADCAST` already exist in `src/lib/websocket/events.ts`. No changes needed to that file.

### Testing Strategy

Due to the real-time nature and WebSocket dependency, this feature requires manual testing with multiple browser tabs/windows. No unit tests required for Phase 1 (can add integration tests later if needed).

**Manual Test Checklist** (Run after Task 4):

1. Start dev server: `pnpm dev`
2. Open game leaderboard in Tab 1
3. Open same game leaderboard in Tab 2 (different browser or incognito)
4. Click üî• in Tab 1 ‚Üí Verify appears in Tab 2 within 100ms
5. Click üòç, üò±, üíÄ ‚Üí Verify all work
6. Disconnect WebSocket (close server) ‚Üí Verify buttons disabled
7. Send 5 reactions quickly ‚Üí Verify all display without overlap
8. Wait 3 seconds ‚Üí Verify reactions auto-remove
9. Send invalid emoji via dev tools ‚Üí Verify server ignores (no broadcast)

### Constitution References

All tasks must follow:

- **architecture.md**: Layer boundaries (WebSocket server, hooks, components)
- **patterns.md**: Modular Component Architecture, Server/Client boundaries, Type safety
- **schema-rules.md**: "No Reaction Table" - ephemeral state only
- **tech-stack.md**: Socket.io, Framer Motion, shadcn/ui
