# Feature: User Pick Wizard - Implementation Plan

> **Generated by:** Task Decomposition skill
> **From spec:** specs/user-pick-wizard/spec.md
> **Created:** 2025-10-20

## Execution Summary

- **Total Tasks**: 11
- **Total Phases**: 5
- **Sequential Time**: 35h
- **Parallel Time**: 22h
- **Time Savings**: 13h (37%)

**Parallelization Opportunities:**
- Phase 2: 3 tasks in parallel (7h saved)
- Phase 3: 2 tasks in parallel (2h saved)
- Phase 4: 3 tasks in parallel (4h saved)

---

## Phase 1: Database Schema & Foundation

**Strategy**: Sequential
**Reason**: Database schema must exist before any models can be created

### Task 1.1: Add GameParticipant Model to Prisma Schema

**Files**:
- `prisma/schema.prisma`
- `prisma/migrations/`

**Complexity**: M (3h)

**Dependencies**: None

**Description**:
Create the GameParticipant model to track which users are members of which games. This enables the "My Games" dashboard and explicit join flow.

**Implementation Steps**:
1. Add GameParticipant model to `prisma/schema.prisma`:
   ```prisma
   model GameParticipant {
     id        String   @id @default(cuid())
     userId    String
     gameId    String
     joinedAt  DateTime @default(now())

     user User @relation(fields: [userId], references: [id], onDelete: Cascade)
     game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

     createdAt DateTime @default(now())
     updatedAt DateTime @updatedAt

     @@unique([userId, gameId])
     @@index([userId])
     @@index([gameId])
   }
   ```
2. Add relation fields to User and Game models:
   - `User.gameParticipants GameParticipant[]`
   - `Game.participants GameParticipant[]`
3. Run `pnpm db:migrate` to create migration
4. Verify migration with `pnpm db:push` in dev
5. Test migration runs cleanly

**Acceptance Criteria**:
- [ ] GameParticipant model added with userId, gameId, joinedAt fields
- [ ] Unique constraint on (userId, gameId) prevents duplicate memberships
- [ ] Indexes on userId and gameId for query performance
- [ ] Relations added to User and Game models
- [ ] Migration runs without errors
- [ ] `pnpm lint` passes

**Mandatory Patterns** (BigNight.Party):
- Schema rules: Follow @docs/constitutions/current/schema-rules.md
- Naming: PascalCase models, camelCase fields
- Indexes: Add indexes on foreign keys and query filters

**Quality Gates**:
```bash
pnpm db:migrate
pnpm db:push
pnpm lint
```

---

## Phase 2: Models Layer (Parallel)

**Strategy**: Parallel
**Reason**: All model files are independent, no shared files

### Task 2.1: Create GameParticipant Model

**Files**:
- `src/lib/models/game-participant-model.ts`

**Complexity**: M (2h)

**Dependencies**: Task 1.1

**Description**:
Implement data access layer for GameParticipant table with CRUD operations for game membership tracking.

**Implementation Steps**:
1. Create `src/lib/models/game-participant-model.ts`
2. Import Prisma client from `src/lib/db/prisma`
3. Implement functions:
   - `create(data: { userId, gameId })` - Create membership
   - `findByUserId(userId: string)` - Get all games for user (with game + event includes)
   - `findByGameId(gameId: string)` - Get all participants for game
   - `exists(userId: string, gameId: string)` - Check if user is member
   - `deleteByUserAndGame(userId: string, gameId: string)` - Remove membership
4. Use Prisma types (no custom types in models layer)
5. **TDD**: Write tests first using `test-driven-development` skill

**Acceptance Criteria**:
- [ ] All functions follow models layer rules (only Prisma queries, no business logic)
- [ ] No imports from services, actions, or next/*
- [ ] Functions are properly typed with Prisma generated types
- [ ] Tests pass (write tests FIRST per TDD)
- [ ] `pnpm lint` passes

**Mandatory Patterns** (BigNight.Party):
- Layer boundaries: Only import @prisma/client and src/lib/db/prisma
- No business logic in models layer
- **TDD**: Write failing test, watch fail, write minimal code, watch pass

**Quality Gates**:
```bash
pnpm test src/lib/models/__tests__/game-participant-model.test.ts
pnpm lint
```

### Task 2.2: Create Pick Model

**Files**:
- `src/lib/models/pick-model.ts`

**Complexity**: M (3h)

**Dependencies**: Task 1.1

**Description**:
Implement data access layer for Pick table with CRUD and upsert operations.

**Implementation Steps**:
1. Create `src/lib/models/pick-model.ts`
2. Import Prisma client from `src/lib/db/prisma`
3. Implement functions:
   - `upsert(data: { gameId, userId, categoryId, nominationId })` - Create or update pick
   - `getPicksByGameAndUser(gameId: string, userId: string)` - Get all picks for user in game
   - `getCompletionCount(gameId: string, userId: string)` - Count picks vs total categories
   - `deleteByUserAndGame(gameId: string, userId: string)` - Clear all picks
4. Use Prisma's upsert with unique constraint (gameId + userId + categoryId)
5. Include related data (category, nomination) in query results
6. **TDD**: Write tests first

**Acceptance Criteria**:
- [ ] Upsert leverages unique constraint correctly
- [ ] Queries include necessary relations (category, nomination)
- [ ] No business logic (validation happens in services)
- [ ] Tests pass (write tests FIRST per TDD)
- [ ] `pnpm lint` passes

**Mandatory Patterns** (BigNight.Party):
- Layer boundaries: Only Prisma queries, no validation
- Upsert pattern: Use Prisma upsert with unique constraint
- **TDD**: Write failing test, watch fail, write minimal code, watch pass

**Quality Gates**:
```bash
pnpm test src/lib/models/__tests__/pick-model.test.ts
pnpm lint
```

### Task 2.3: Extend Nomination and Category Models

**Files**:
- `src/lib/models/nomination-model.ts`
- `src/lib/models/category-model.ts`

**Complexity**: S (2h)

**Dependencies**: Task 1.1

**Description**:
Add query methods to existing models for fetching nominations by category and categories by event.

**Implementation Steps**:
1. Check if files exist, create if needed
2. In `nomination-model.ts`:
   - Add `getNominationsByCategoryId(categoryId: string)`
   - Include Work and Person relations for card display
   - Order by nomination order if exists
3. In `category-model.ts`:
   - Add `getCategoriesByEventId(eventId: string)`
   - Order by `order` field (ascending)
4. **TDD**: Write tests first

**Acceptance Criteria**:
- [ ] getNominationsByCategoryId includes Work and Person data
- [ ] getCategoriesByEventId ordered by Category.order field
- [ ] Functions follow models layer rules
- [ ] Tests pass (write tests FIRST per TDD)
- [ ] `pnpm lint` passes

**Mandatory Patterns** (BigNight.Party):
- Layer boundaries: Only Prisma queries in models
- Include relations for UI display needs
- **TDD**: Write failing test, watch fail, write minimal code, watch pass

**Quality Gates**:
```bash
pnpm test src/lib/models/__tests__/nomination-model.test.ts
pnpm test src/lib/models/__tests__/category-model.test.ts
pnpm lint
```

---

## Phase 3: Services Layer (Parallel)

**Strategy**: Parallel
**Reason**: game-service and pick-service are independent

### Task 3.1: Create Game Service with Membership Logic

**Files**:
- `src/lib/services/game-service.ts`

**Complexity**: M (3h)

**Dependencies**: Task 2.1

**Description**:
Implement business logic for game membership: joining games, checking membership, resolving access codes.

**Implementation Steps**:
1. Create `src/lib/services/game-service.ts`
2. Import models: `game-participant-model`, `game-model`
3. Implement functions:
   - `joinGame(userId: string, gameId: string)` - Create GameParticipant record
   - `checkMembership(userId: string, gameId: string)` - Boolean check
   - `getUserGames(userId: string)` - Get all games with completion counts
   - `resolveAccessCode(code: string, userId: string)` - Get gameId + membership status
4. Use ts-pattern for any status checks
5. Call model layer only (no direct Prisma)
6. **TDD**: Write tests first with mocked models

**Acceptance Criteria**:
- [ ] joinGame validates game exists before creating participant
- [ ] getUserGames calculates completion count (picks vs categories)
- [ ] resolveAccessCode returns { gameId, isMember } object
- [ ] No direct Prisma imports (only model layer calls)
- [ ] Tests pass with mocked models (write tests FIRST per TDD)
- [ ] `pnpm lint` passes

**Mandatory Patterns** (BigNight.Party):
- Layer boundaries: Call models only, no Prisma direct
- Pattern matching: Use ts-pattern with .exhaustive() for any status checks
- **TDD**: Write failing test, watch fail, write minimal code, watch pass

**Quality Gates**:
```bash
pnpm test src/lib/services/__tests__/game-service.test.ts
pnpm lint
```

### Task 3.2: Create Pick Service with Validation Logic

**Files**:
- `src/lib/services/pick-service.ts`

**Complexity**: M (4h)

**Dependencies**: Task 2.2, Task 2.3

**Description**:
Implement business logic for pick submission including game status validation, membership checks, and nomination validation.

**Implementation Steps**:
1. Create `src/lib/services/pick-service.ts`
2. Import models: `pick-model`, `game-model`, `game-participant-model`, `nomination-model`
3. Implement `submitPick(userId: string, data: { gameId, categoryId, nominationId })`:
   - Validate user is game participant
   - Fetch game and check status with ts-pattern
   - Match game.status with 'OPEN' → allow, otherwise → reject
   - Validate nomination belongs to category
   - Call pickModel.upsert
4. Use ts-pattern for GameStatus checking with .exhaustive()
5. Return typed Result<Pick, Error>
6. **TDD**: Write tests first with mocked models

**Acceptance Criteria**:
- [ ] Validates user is game participant before allowing pick
- [ ] Uses ts-pattern with .exhaustive() for game status check
- [ ] Rejects picks when game.status !== 'OPEN'
- [ ] Validates nomination belongs to category
- [ ] No direct Prisma imports
- [ ] Tests pass with mocked models (write tests FIRST per TDD)
- [ ] `pnpm lint` passes

**Mandatory Patterns** (BigNight.Party):
- Pattern matching: Use ts-pattern for GameStatus with .exhaustive()
- Layer boundaries: Call models only
- Error handling: Return typed Result<T, E>
- **TDD**: Write failing test, watch fail, write minimal code, watch pass

**Quality Gates**:
```bash
pnpm test src/lib/services/__tests__/pick-service.test.ts
pnpm lint
```

---

## Phase 4: Actions & Schemas (Parallel)

**Strategy**: Parallel
**Reason**: Actions and schemas are independent

### Task 4.1: Create Zod Schemas

**Files**:
- `src/schemas/pick-schema.ts`
- `src/schemas/game-schema.ts`

**Complexity**: S (1h)

**Dependencies**: None

**Description**:
Define Zod validation schemas for pick submission and game joining.

**Implementation Steps**:
1. Create `src/schemas/pick-schema.ts`:
   ```typescript
   export const pickSchema = z.object({
     gameId: z.string().cuid(),
     categoryId: z.string().cuid(),
     nominationId: z.string().cuid(),
   })
   ```
2. Create `src/schemas/game-schema.ts`:
   ```typescript
   export const joinGameSchema = z.object({
     gameId: z.string().cuid(),
   })

   export const resolveCodeSchema = z.object({
     code: z.string().min(4).max(20),
   })
   ```
3. Export type inferences for use in actions

**Acceptance Criteria**:
- [ ] pickSchema validates all required fields (gameId, categoryId, nominationId)
- [ ] CUID validation on ID fields
- [ ] Schemas export inferred TypeScript types
- [ ] `pnpm lint` passes

**Mandatory Patterns** (BigNight.Party):
- All schemas in src/schemas/
- Use z.string().cuid() for ID validation
- Export types with z.infer<typeof schema>

**Quality Gates**:
```bash
pnpm lint
```

### Task 4.2: Create Game Actions

**Files**:
- `src/lib/actions/game-actions.ts`

**Complexity**: M (2h)

**Dependencies**: Task 3.1, Task 4.1

**Description**:
Create server actions for joining games using next-safe-action with authentication.

**Implementation Steps**:
1. Create `src/lib/actions/game-actions.ts`
2. Import `authenticatedAction` from `src/lib/actions/safe-action.ts`
3. Import schemas from `src/schemas/game-schema.ts`
4. Implement actions:
   ```typescript
   export const joinGameAction = authenticatedAction
     .schema(joinGameSchema)
     .action(async ({ parsedInput, ctx }) => {
       return gameService.joinGame(ctx.userId, parsedInput.gameId)
     })
   ```
5. **TDD**: Write tests first

**Acceptance Criteria**:
- [ ] All actions use authenticatedAction (provides ctx.userId)
- [ ] All actions use Zod schema validation
- [ ] Actions delegate to game service (no business logic in actions)
- [ ] Tests pass (write tests FIRST per TDD)
- [ ] `pnpm lint` passes

**Mandatory Patterns** (BigNight.Party):
- **REQUIRED**: Use next-safe-action for ALL server actions
- Auth: Use authenticatedAction for auth context
- Validation: Schema validation via .schema()
- **TDD**: Write failing test, watch fail, write minimal code, watch pass

**Quality Gates**:
```bash
pnpm test src/lib/actions/__tests__/game-actions.test.ts
pnpm lint
```

### Task 4.3: Create Pick Actions

**Files**:
- `src/lib/actions/pick-actions.ts`

**Complexity**: M (2h)

**Dependencies**: Task 3.2, Task 4.1

**Description**:
Create server actions for pick submission using next-safe-action with authentication and validation.

**Implementation Steps**:
1. Create `src/lib/actions/pick-actions.ts`
2. Import `authenticatedAction` from `src/lib/actions/safe-action.ts`
3. Import `pickSchema` from `src/schemas/pick-schema.ts`
4. Implement action:
   ```typescript
   export const submitPickAction = authenticatedAction
     .schema(pickSchema)
     .action(async ({ parsedInput, ctx }) => {
       return pickService.submitPick(ctx.userId, parsedInput)
     })
   ```
5. **TDD**: Write tests first

**Acceptance Criteria**:
- [ ] submitPickAction uses authenticatedAction
- [ ] Input validated with pickSchema
- [ ] Delegates to pick service (no business logic)
- [ ] Error handling returns typed errors
- [ ] Tests pass (write tests FIRST per TDD)
- [ ] `pnpm lint` passes

**Mandatory Patterns** (BigNight.Party):
- **REQUIRED**: Use next-safe-action for ALL server actions
- Auth: Use authenticatedAction
- Validation: Schema validation via .schema()
- **TDD**: Write failing test, watch fail, write minimal code, watch pass

**Quality Gates**:
```bash
pnpm test src/lib/actions/__tests__/pick-actions.test.ts
pnpm lint
```

---

## Phase 5: UI Layer (Sequential)

**Strategy**: Sequential
**Reason**: UI components depend on each other and build upon foundation routes

### Task 5.1: Create Dashboard & Signup Pages

**Files**:
- `src/app/dashboard/page.tsx`
- `src/app/signup/page.tsx`
- `src/app/(auth)/sign-in/page.tsx`
- `src/components/game-list-item.tsx`

**Complexity**: M (4h)

**Dependencies**: Task 3.1, Task 4.2

**Description**:
Implement user dashboard showing "My Games" list, signup page with invite code capture, and modify sign-in for code handling.

**Implementation Steps**:
1. Create `src/app/signup/page.tsx`:
   - Server Component that captures `?code=X` query param
   - Show sign-in form (reuse existing component)
   - Store code in session/cookie for post-auth redirect
2. Modify `src/app/(auth)/sign-in/page.tsx`:
   - Check for pending invite code after auth
   - If code exists, call `joinGameAction`, show toast, redirect to `/dashboard`
   - If no code, redirect to `/dashboard`
3. Create `src/app/dashboard/page.tsx`:
   - Server Component fetches user's games via `gameService.getUserGames(userId)`
   - Display game cards showing: name, event, status, completion (X/Y categories)
   - Each card links to `/game/[gameId]/pick`
4. Create `src/components/game-list-item.tsx`:
   - Client Component for game card
   - Props: game data, onClick handler
   - Responsive design (mobile/desktop)
5. **TDD**: Write component tests first

**Acceptance Criteria**:
- [ ] Signup page captures `?code` query param
- [ ] Sign-in callback auto-joins game if code present
- [ ] Success toast shows "✓ You've joined [Game Name]!" for 5 seconds
- [ ] Dashboard shows all user's games with completion counts
- [ ] Game cards link to `/game/[gameId]/pick`
- [ ] Mobile responsive layout
- [ ] Tests pass (write tests FIRST per TDD)
- [ ] `pnpm lint` passes

**Mandatory Patterns** (BigNight.Party):
- Server Components: Can be async, call services directly
- Client Components: Use "use client", handle interactivity
- No event handlers in Server Components
- **TDD**: Write failing test, watch fail, write minimal code, watch pass

**Quality Gates**:
```bash
pnpm test src/app/dashboard/__tests__/page.test.tsx
pnpm test src/components/__tests__/game-list-item.test.tsx
pnpm lint
```

### Task 5.2: Create Game Access Resolver Page

**Files**:
- `src/app/game/[code]/page.tsx`

**Complexity**: M (3h)

**Dependencies**: Task 3.1, Task 4.2

**Description**:
Implement game access page that checks membership and either redirects to pick wizard or shows join button.

**Implementation Steps**:
1. Create `src/app/game/[code]/page.tsx`
2. Server Component that:
   - Extracts `code` from params
   - Calls `gameService.resolveAccessCode(code, userId)`
   - If `isMember === true`: `redirect(/game/${gameId}/pick)`
   - If `isMember === false`: Show game info + "Join Game" button
3. Game info shows: game name, event name, event date, status
4. "Join Game" button:
   - Client Component `<JoinGameButton>`
   - Calls `joinGameAction({ gameId })`
   - On success, redirect to `/game/${gameId}/pick`
5. **TDD**: Write tests first

**Acceptance Criteria**:
- [ ] Resolves gameId from access code
- [ ] Members automatically redirected to pick wizard
- [ ] Non-members see game info and join button
- [ ] Join button creates GameParticipant and redirects
- [ ] Invalid codes show 404 or error message
- [ ] Tests pass (write tests FIRST per TDD)
- [ ] `pnpm lint` passes

**Mandatory Patterns** (BigNight.Party):
- Server Components: Use redirect() from next/navigation
- Client Components: Button with onClick for actions
- **TDD**: Write failing test, watch fail, write minimal code, watch pass

**Quality Gates**:
```bash
pnpm test src/app/game/[code]/__tests__/page.test.tsx
pnpm lint
```

### Task 5.3: Create Pick Wizard Page & Components

**Files**:
- `src/app/game/[gameId]/pick/page.tsx`
- `src/components/pick-wizard.tsx`
- `src/components/nominee-card.tsx`
- `src/components/category-progress-stepper.tsx`

**Complexity**: L (6h)

**Dependencies**: Task 3.2, Task 4.3

**Description**:
Implement the complete pick wizard with category navigation, nominee cards, autosave, progress stepper, and lock time warning.

**Implementation Steps**:
1. Create `src/app/game/[gameId]/pick/page.tsx`:
   - Server Component fetches data based on `gameId` and `?category` query param
   - Verify user is participant (redirect if not)
   - Fetch game, categories, nominations, existing picks
   - Check lock time warning conditions
   - Pass data to Client Components
2. Create `src/components/pick-wizard.tsx`:
   - Client Component with URL state management
   - Props: categories, currentCategoryId, existingPicks, isLocked
   - State: selectedNominationId, isSaving
   - Navigation: Previous/Next buttons update `?category` query param
   - Autosave: Call submitPickAction on selection
   - Show save indicator: "Saving..." → "Saved ✓"
   - Lock time warning banner if within 30 minutes
3. Create `src/components/nominee-card.tsx`:
   - Client Component for selectable card
   - Props: nomination data, isSelected, isLocked, onClick
   - Display: image (or placeholder), nomination text, work/person details
   - Visual states: default, hover, selected, locked
   - Wrap nomination text (no truncation)
4. Create `src/components/category-progress-stepper.tsx`:
   - Client Component for category navigation
   - Props: categories, currentCategoryId, completedCategories
   - Clickable category indicators
   - Show progress: "Category X of Y • Z completed"
   - Horizontal scroll on mobile
5. **TDD**: Write component tests first

**Acceptance Criteria**:
- [ ] Categories displayed in Category.order ascending
- [ ] Nominee cards show images with placeholder fallback
- [ ] Nomination text wraps (no truncation)
- [ ] Pick autosaves on selection with indicator
- [ ] Previous/Next buttons navigate categories
- [ ] Progress stepper shows completion count
- [ ] Category indicators clickable to jump
- [ ] Lock time warning shows if within 30 mins and incomplete
- [ ] When locked, all cards disabled with banner
- [ ] Mobile responsive (1 column cards, scrollable stepper)
- [ ] Browser back/forward buttons work
- [ ] Tests pass (write tests FIRST per TDD)
- [ ] `pnpm lint` passes

**Mandatory Patterns** (BigNight.Party):
- Server Components: Async data fetching
- Client Components: "use client" for interactivity
- Form actions: Use inline server actions or useAction hook
- **TDD**: Write failing test, watch fail, write minimal code, watch pass

**Quality Gates**:
```bash
pnpm test src/app/game/[gameId]/pick/__tests__/page.test.tsx
pnpm test src/components/__tests__/pick-wizard.test.tsx
pnpm test src/components/__tests__/nominee-card.test.tsx
pnpm test src/components/__tests__/category-progress-stepper.test.tsx
pnpm lint
```

---

## Summary of Dependencies

```
Phase 1 (Database)
  └─> Phase 2 (Models) - All parallel
        ├─> Task 2.1 → Phase 3.1 (Game Service)
        ├─> Task 2.2 → Phase 3.2 (Pick Service)
        └─> Task 2.3 → Phase 3.2 (Pick Service)

Phase 3 (Services) - Parallel
  └─> Phase 4 (Actions & Schemas) - Parallel
        ├─> Task 4.1 (Schemas) - No deps
        ├─> Task 4.2 (Game Actions) → Task 5.1, 5.2
        └─> Task 4.3 (Pick Actions) → Task 5.3

Phase 4 (Actions)
  └─> Phase 5 (UI) - Sequential
        Task 5.1 → Task 5.2 → Task 5.3
```

## Complexity Breakdown

- **S (1-2h)**: 2 tasks
- **M (2-4h)**: 7 tasks
- **L (4-8h)**: 2 tasks
- **XL (>8h)**: 0 tasks ✓

## Time Estimates

- **Sequential Execution**: 35h
- **With Parallelization**: 22h
- **Time Savings**: 13h (37% faster)

## Constitution Compliance Checklist

Every task must verify:
- [ ] Server actions use next-safe-action
- [ ] Discriminated unions use ts-pattern with .exhaustive()
- [ ] Layer boundaries respected (no Prisma outside models/)
- [ ] All inputs validated with Zod
- [ ] TDD followed (test first, watch fail, minimal code, watch pass)
- [ ] Tests pass
- [ ] Linting passes
