---
name: task-decomposition
description: Use when you have a complete feature spec and need to plan implementation - analyzes task dependencies, groups into sequential/parallel phases, validates task quality (no XL tasks, explicit files), and calculates parallelization time savings
---

# Task Decomposition

Analyze a feature specification and decompose it into an execution-ready plan with automatic phase grouping based on file dependencies.

**When to use:** After completing a feature spec, before implementation.

**Announce:** "I'm using the Task Decomposition skill to create an execution plan."

## Overview

This skill transforms a feature specification into a structured implementation plan by:
1. Extracting tasks from spec
2. Analyzing file dependencies between tasks
3. Grouping into phases (sequential or parallel)
4. Validating task quality
5. Outputting executable plan.md

## The Process

### Step 1: Read and Extract Tasks

Read the spec file and extract all tasks from the "Implementation Plan" section.

For each task, capture:
- **Task ID** (from heading)
- **Description** (what to implement)
- **Files** (explicit paths from spec)
- **Complexity** (S/M/L/XL - estimated hours)
- **Acceptance Criteria** (checklist items)
- **Implementation Steps** (detailed steps)

**Example extraction:**
```markdown
Spec has:
### Task 1: Database Schema
**Complexity**: M (2-4h)
**Files**:
- prisma/schema.prisma
- prisma/migrations/

**Description**: Add VerificationToken model for Auth.js...

**Acceptance**:
- [ ] Model matches Auth.js spec
- [ ] Migration runs cleanly

Extract to:
{
  id: "task-1-database-schema",
  description: "Add VerificationToken model",
  files: ["prisma/schema.prisma", "prisma/migrations/"],
  complexity: "M",
  estimated_hours: 3,
  acceptance_criteria: [...],
  steps: [...]
}
```

### Step 2: Validate Task Quality

For each task, check for quality issues:

**CRITICAL (must fix):**
- ❌ XL complexity (>8h) → Must split into M tasks
- ❌ No files specified → Must add explicit file paths
- ❌ No acceptance criteria → Must add 3-5 testable criteria
- ❌ Wildcard patterns (`src/**/*.ts`) → Must use explicit paths

**HIGH (strongly recommend):**
- ⚠️ L complexity (4-8h) → Consider splitting to M
- ⚠️ >10 files → Likely too large, consider splitting
- ⚠️ <50 char description → Add more detail
- ⚠️ <3 acceptance criteria → Add more specific criteria

**If CRITICAL issues found:**
- STOP and report issues to user
- User must update spec
- Re-run skill after spec update

**If only HIGH issues:**
- Report warnings
- Offer to continue or fix

### Step 3: Analyze File Dependencies

Build dependency graph by analyzing file overlaps:

**Algorithm:**
```
For each task T1:
  For each task T2 (where T2 appears after T1):
    shared_files = intersection(T1.files, T2.files)

    If shared_files is not empty:
      T2.dependencies.add(T1.id)
      T2.dependency_reason = "Shares files: {shared_files}"
```

**Example:**
```
Task 1: ["prisma/schema.prisma"]
Task 2: ["src/lib/models/auth.ts"]
Task 3: ["prisma/schema.prisma", "src/types/auth.ts"]

Analysis:
- Task 2: No dependencies (no shared files with Task 1)
- Task 3: Depends on Task 1 (shares prisma/schema.prisma)
```

**Architectural dependencies:**
Also add dependencies based on layer order:
- Models → Services → Actions → UI
- Database → Types → Logic → API → Components

### Step 4: Group into Phases

Group tasks into phases using dependency graph:

**Phase grouping algorithm:**
```
1. Start with tasks that have no dependencies (roots)
2. Group all independent roots into Phase 1
3. Remove roots from graph
4. Repeat until all tasks grouped

For each phase:
  - If all tasks independent: strategy = "parallel"
  - If any dependencies exist: strategy = "sequential"
```

**Example:**
```
Tasks:
- Task 1: [] (no deps)
- Task 2: [] (no deps)
- Task 3: [task-1, task-2]
- Task 4: [task-3]

Grouping:
Phase 1: [Task 1, Task 2] - parallel (independent)
Phase 2: [Task 3] - sequential (waits for Phase 1)
Phase 3: [Task 4] - sequential (waits for Phase 2)
```

### Step 5: Calculate Execution Estimates

For each phase, calculate:
- **Sequential time**: Sum of all task hours
- **Parallel time**: Max of all task hours (if parallel strategy)
- **Time savings**: Sequential - Parallel

**Example:**
```
Phase 2 (parallel):
- Task A: 3h
- Task B: 2h
- Task C: 4h

Sequential: 3 + 2 + 4 = 9h
Parallel: max(3, 2, 4) = 4h
Savings: 9 - 4 = 5h (56% faster)
```

### Step 6: Generate plan.md

Write plan to `{spec-directory}/plan.md`:

**Template:**
```markdown
# Feature: {Feature Name} - Implementation Plan

> **Generated by:** Task Decomposition skill
> **From spec:** {spec-path}
> **Created:** {date}

## Execution Summary

- **Total Tasks**: {count}
- **Total Phases**: {count}
- **Sequential Time**: {hours}h
- **Parallel Time**: {hours}h
- **Time Savings**: {hours}h ({percent}%)

**Parallel Opportunities:**
- Phase {id}: {task-count} tasks ({hours}h saved)

---

## Phase {N}: {Phase Name}

**Strategy**: {sequential|parallel}
**Reason**: {why this strategy}

### Task {ID}: {Name}

**Files**:
- {file-path-1}
- {file-path-2}

**Complexity**: {S|M|L} ({hours}h)

**Dependencies**: {[task-ids] or "None"}

**Description**:
{What to implement and why}

**Implementation Steps**:
1. {step-1}
2. {step-2}
3. {step-3}

**Acceptance Criteria**:
- [ ] {criterion-1}
- [ ] {criterion-2}
- [ ] {criterion-3}

**Mandatory Patterns** (BigNight.Party):
- Server actions: Use next-safe-action
- Discriminated unions: Use ts-pattern with .exhaustive()
- Layer boundaries: {specific guidance}
- **TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)

**Quality Gates**:
```bash
pnpm biome check --write .
pnpm test {test-files}
```

---

{Repeat for all tasks in all phases}
```

### Step 7: Report to User

After generating plan:

```markdown
✅ Task Decomposition Complete

**Plan Location**: specs/features/{feature-name}/plan.md

## Breakdown
- Phases: {count}
- Tasks: {count}
- Complexity: {XL}: {n}, {L}: {n}, {M}: {n}, {S}: {n}

## Execution Strategy
- Sequential Phases: {count} ({tasks} tasks)
- Parallel Phases: {count} ({tasks} tasks)

## Time Estimates
- Sequential Execution: {hours}h
- With Parallelization: {hours}h
- **Time Savings: {hours}h ({percent}% faster)**

## Next Steps

Review plan:
```bash
cat specs/features/{feature-name}/plan.md
```

Execute plan:
```bash
/execute @specs/features/{feature-name}/plan.md
```
```

## Quality Rules

**Task Sizing:**
- ✅ S (1-2h): Simple, focused tasks
- ✅ M (2-4h): Standard task size (most common)
- ✅ L (4-8h): Complex tasks (use sparingly)
- ❌ XL (>8h): NEVER - always split into M tasks

**File Specificity:**
- ✅ `src/lib/models/auth.ts`
- ✅ `src/components/auth/LoginForm.tsx`
- ❌ `src/**/*.ts` (too vague)
- ❌ `src/lib/models/` (specify exact files)

**Acceptance Criteria:**
- ✅ 3-5 specific, testable criteria
- ✅ Quantifiable (tests pass, build succeeds, API returns 200)
- ❌ Vague ("works well", "is good")
- ❌ Too many (>7 - task is too large)

**Dependencies:**
- ✅ Minimal (only true blockers)
- ✅ Explicit reasons (shares file X)
- ❌ Circular dependencies
- ❌ Over-constrained (everything depends on everything)

## Error Handling

### Spec Has No Tasks

If spec doesn't have "Implementation Plan" section:

```
❌ Cannot decompose - spec has no tasks

The spec must have an "Implementation Plan" section with tasks.

Use /spec-feature to generate a complete spec first.
```

### Critical Quality Issues

If tasks have critical issues:

```
❌ Task Quality Issues - Cannot Generate Plan

Critical Issues Found:
- Task 3: XL complexity (12h) - must split
- Task 5: No files specified
- Task 7: No acceptance criteria

Fix these issues in the spec, then re-run:
/plan @specs/features/{name}.md
```

### Circular Dependencies

If dependency graph has cycles:

```
❌ Circular Dependencies Detected

Task A depends on Task B
Task B depends on Task C
Task C depends on Task A

This is impossible to execute. Review task organization.
```

## Integration with Other Skills

**Before:** Use `brainstorming` and `spec-feature` to create complete spec

**After:** Use `/execute` command to run plan with `subagent-driven-development`

**Pairs with:**
- `subagent-driven-development` - Executes individual tasks
- `finishing-a-development-branch` - Completes implementation

## BigNight.Party Specific

For BigNight.Party projects, enforce these patterns in task validation:

**Layer order dependencies:**
```
Database (Prisma schema)
  ↓
Models (src/lib/models/)
  ↓
Services (src/lib/services/)
  ↓
Actions (src/lib/actions/)
  ↓
Components (src/components/)
```

**Mandatory patterns reminder:**
Every task must include reminders about:
- next-safe-action for server actions
- ts-pattern for discriminated unions
- No Prisma imports outside models layer

**Quality gates:**
Every task must include:
```bash
pnpm biome check --write .
pnpm test
```
